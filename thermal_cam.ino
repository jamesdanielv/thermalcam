//this is better with included zip package that has all needed libraries in it for testing.
//most updated version of thermal_cam file can replace the one in zip file
//this is a work in process. 16x16 subsample seems to work ok, trying to verify 32x32 and add up to 512 by 512
//some changes may be needed to have includes location changes also spixx.h just uses libray in file change back to <spi.h>
//this is the only file where code changes are, so just replace old file with this one 
//and change libary include file locations
//32x32 might need work. will need to first increase color table to be sure
//located here on github :https://github.com/jamesdanielv/thermalcam/edit/master/thermal_cam.ino
/***************************************************************************
  This is a library for the AMG88xx GridEYE 8x8 IR camera
  This sketch makes a 64 pixel thermal camera with the GridEYE sensor
  and a 128x128 tft screen https://www.adafruit.com/product/2088
  Designed specifically to work with the Adafruit AMG88 breakout
  ----> http://www.adafruit.com/products/3538
  These sensors use I2C to communicate. The device's I2C address is 0x69
  Adafruit invests time and resources providing this open source code,
  please support Adafruit andopen-source hardware by purchasing products
  from Adafruit!
  Written by Dean Miller for Adafruit Industries.
  BSD license, all text above must be included in any redistribution
 ***************************************************************************/

#include "Adafruit_GFX.h"    // Core graphics library
#include "Adafruit_ST7735.h" // Hardware-specific library
#include "SPIxx.h" //built in library should be SPI.h 
#include "Adafruit_SPITFT_Macros.h"
#include <Wire.h>
#include "Adafruit_AMG88xx.h"
#include <avr/pgmspace.h>

//these 3 will need to be redefined in Adafruit_ST77xx.ccp file for small amount of time. seems some slow pixel writing on arduino otherwise!
#define TFT_CS     10 //chip select pin for the TFT screen
#define TFT_RST    9  // you can also connect this to the Arduino reset
                      // in which case, set this #define pin to 0!
#define TFT_DC     8
#define autorange true  //this adjust temp range over the color range of the screen experimental
//low range of the sensor (this will be blue on the screen)
#if autorange == false
#define MINTEMP 24

//high range of the sensor (this will be red on the screen)
#define MAXTEMP 34
#else
int MINTEMP =24;
int MAXTEMP =34; //we turn this into int value that can be adjusted
#endif

// 0 no optimse |1 pixels only written whe color changed| 2 pixels also optimized for most changed ones first (deals with noise issues)
#define optimize  2 //

#define interpolatemode 3 //can be 0-3 so far 0=8x8 1=16x16 2=32x32 3=64x64 only try 64x64 on atmega or greater. needs at least 4k of ram for those systems for now 
//experimental subpixelcoloroptimized=3 more only works on interpolate mode 3, for interpolate mode 1,0 use subpixelcoloroptimized=0

//noise filter experimental also in 64x64 mode small pixel changes are dramatic. having this on in 64x64 will have pixel popping. still working on fix or smoothing
#define noisefilter 2 //0 is off.  this means temp variation needs to be greater than this for data to be sent to lcd, also you could program interupt of amg8833 for this as well

//*******************************below lines are for making device into a thermal pointing device look in Adafruit_AMG88xx.cpp for mirroring of sensor data (in this version)
// look in Adafruit_AMG88xx.cpp file for a setting called #define AMG88xx_PIXEL_MIRROR //this mirrors image from left to right to right to left for sensor, such as when amg8833 device is pointing away from display. 
#define show_temp_readout true //this shows center dot, and right below the temp for that dot. if false wont show anything
#define temp_Fahrenheit true //we convert output temp to F, otherwise it is c
#define showcolorbar true //this shows color range and bar. more useful for autorange
//***********************************

//const dataType variableName[] PROGMEM = {data0, data1, data3…​};// how to formate table for progmem or the way it is listed. in order for it to work correctly int needs to be reconverted to  (uint16_t)
//the colors we will be using stored into a flash instead of ram which is valuable on arudino just use (uint16_t)pgm_read_word_near(camColors+ instead of Camcolors[]
#define colorMode 21 //can be 0=64 color adafruit, 1=256 color map 0,1 use same 256 color table space,2=1024 colors , or color=21 for alternate 1024 color map, 22 for mostl black and white with high temp in color, 23 another color mode 
#define spi_optimized_st77xx true //false if using normal driver//these files are upaded and specific for this code needed st77xx,h, st77xx.cpp need downloaded from https://github.com/jamesdanielv/thermalcam/blob/master/colorgenerator
#define subpixelcoloroptimized 2 //0= normal, 1= 4 pixels,2=16 pixels, 3=64 pixels. requires custom st77xx.ccp, and st77xx.h files included in main folder  (4- 64 samples at a time!), -1 blank for understanding loop other than lcd writes
//subpixelcoloroptimized onl work with custom st77xx files currently and are only enabled if 32x32 or 64x64 subsampled enabled.
#if spi_optimized_st77xx == true
#define fillRectFast tft.fillRectFast
#else
#define fillRectFast tft.fillRect
#endif

#if colorMode == 0
const PROGMEM uint16_t camColors[] =  {0x480F,
0x400F,0x400F,0x400F,0x4010,0x3810,0x3810,0x3810,0x3810,0x3010,0x3010,
0x3010,0x2810,0x2810,0x2810,0x2810,0x2010,0x2010,0x2010,0x1810,0x1810,
0x1811,0x1811,0x1011,0x1011,0x1011,0x0811,0x0811,0x0811,0x0011,0x0011,
0x0011,0x0011,0x0011,0x0031,0x0031,0x0051,0x0072,0x0072,0x0092,0x00B2,
0x00B2,0x00D2,0x00F2,0x00F2,0x0112,0x0132,0x0152,0x0152,0x0172,0x0192,
0x0192,0x01B2,0x01D2,0x01F3,0x01F3,0x0213,0x0233,0x0253,0x0253,0x0273,
0x0293,0x02B3,0x02D3,0x02D3,0x02F3,0x0313,0x0333,0x0333,0x0353,0x0373,
0x0394,0x03B4,0x03D4,0x03D4,0x03F4,0x0414,0x0434,0x0454,0x0474,0x0474,
0x0494,0x04B4,0x04D4,0x04F4,0x0514,0x0534,0x0534,0x0554,0x0554,0x0574,
0x0574,0x0573,0x0573,0x0573,0x0572,0x0572,0x0572,0x0571,0x0591,0x0591,
0x0590,0x0590,0x058F,0x058F,0x058F,0x058E,0x05AE,0x05AE,0x05AD,0x05AD,
0x05AD,0x05AC,0x05AC,0x05AB,0x05CB,0x05CB,0x05CA,0x05CA,0x05CA,0x05C9,
0x05C9,0x05C8,0x05E8,0x05E8,0x05E7,0x05E7,0x05E6,0x05E6,0x05E6,0x05E5,
0x05E5,0x0604,0x0604,0x0604,0x0603,0x0603,0x0602,0x0602,0x0601,0x0621,
0x0621,0x0620,0x0620,0x0620,0x0620,0x0E20,0x0E20,0x0E40,0x1640,0x1640,
0x1E40,0x1E40,0x2640,0x2640,0x2E40,0x2E60,0x3660,0x3660,0x3E60,0x3E60,
0x3E60,0x4660,0x4660,0x4E60,0x4E80,0x5680,0x5680,0x5E80,0x5E80,0x6680,
0x6680,0x6E80,0x6EA0,0x76A0,0x76A0,0x7EA0,0x7EA0,0x86A0,0x86A0,0x8EA0,
0x8EC0,0x96C0,0x96C0,0x9EC0,0x9EC0,0xA6C0,0xAEC0,0xAEC0,0xB6E0,0xB6E0,
0xBEE0,0xBEE0,0xC6E0,0xC6E0,0xCEE0,0xCEE0,0xD6E0,0xD700,0xDF00,0xDEE0,
0xDEC0,0xDEA0,0xDE80,0xDE80,0xE660,0xE640,0xE620,0xE600,0xE5E0,0xE5C0,
0xE5A0,0xE580,0xE560,0xE540,0xE520,0xE500,0xE4E0,0xE4C0,0xE4A0,0xE480,
0xE460,0xEC40,0xEC20,0xEC00,0xEBE0,0xEBC0,0xEBA0,0xEB80,0xEB60,0xEB40,
0xEB20,0xEB00,0xEAE0,0xEAC0,0xEAA0,0xEA80,0xEA60,0xEA40,0xF220,0xF200,
0xF1E0,0xF1C0,0xF1A0,0xF180,0xF160,0xF140,0xF100,0xF0E0,0xF0C0,0xF0A0,
0xF080,0xF060,0xF040,0xF020,0xF800,};
#endif

#if colorMode == 1
const PROGMEM uint16_t camColors[] =  
{0x0003,0x0004,0x0004,0x0005,0x0006,0x0006,0x0007,0x0027,0x0028,
0x0028,0x0029,0x002a,0x002a,0x002b,0x002b,0x002c,0x002d,0x002d,
0x002e,0x002e,0x002f,0x004f,0x0050,0x0051,0x0051,0x0052,0x0052,
0x0053,0x0053,0x0054,0x0055,0x0055,0x0056,0x0056,0x0057,0x0057,
0x0078,0x0079,0x0079,0x007a,0x007a,0x007b,0x007c,0x007c,0x007d,
0x007d,0x007e,0x007e,0x007f,0x009f,0x00bf,0x00de,0x00fe,0x011d,
0x013d,0x015c,0x017c,0x019b,0x01ba,0x01fa,0x0219,0x0239,0x0258,
0x0278,0x0297,0x02b7,0x02d6,0x02f6,0x0315,0x0334,0x0374,0x0393,
0x03b3,0x03d2,0x03f2,0x0411,0x0431,0x0450,0x0470,0x048f,0x04ae,
0x04ce,0x050d,0x052d,0x054c,0x056c,0x058b,0x05ab,0x05ca,0x05ea,
0x0609,0x0628,0x0648,0x0687,0x06a7,0x06c6,0x06e6,0x0705,0x0725,
0x0744,0x0764,0x0783,0x07a2,0x07c2,0x07e1,0x07e1,0x0fe1,0x0fe1,
0x17e1,0x17e1,0x1fe1,0x1fe1,0x27e1,0x2fe1,0x2fe1,0x37e1,0x37e1,
0x3fe1,0x3fc1,0x47c1,0x47c1,0x4fc1,0x4fc1,0x57c1,0x5fc1,0x5fc1,
0x67c1,0x67c1,0x6fc1,0x6fc1,0x77c1,0x77c1,0x7fa0,0x7fa0,0x87a0,
0x87a0,0x8fa0,0x97a0,0x97a0,0x9fa0,0x9fa0,0xa7a0,0xa7a0,0xafa0,
0xafa0,0xb7a0,0xb7a0,0xbf80,0xc780,0xc780,0xcf80,0xcf80,0xd780,
0xd780,0xdf80,0xdf80,0xe780,0xe780,0xef80,0xf780,0xf760,0xf760,
0xf760,0xf740,0xf740,0xf740,0xf721,0xf721,0xf721,0xf701,0xf701,
0xf701,0xf6e2,0xf6e2,0xf6e2,0xf6c2,0xf6c2,0xf6c2,0xf6a2,0xf6a3,
0xf6a3,0xf683,0xf683,0xf683,0xf663,0xf664,0xf644,0xfe44,0xfe44,
0xfe24,0xfe24,0xfe25,0xfe05,0xfe05,0xfe05,0xfde5,0xfde5,0xfde5,
0xfdc6,0xfdc6,0xfdc6,0xfda6,0xfda6,0xfda6,0xfd87,0xfd87,0xfd87,
0xfd67,0xfd67,0xfd67,0xfd47,0xfd48,0xfd48,0xfd28,0xfd28,0xfd08,
0xfd08,0xfce8,0xfcc7,0xfca7,0xfca7,0xfc87,0xfc67,0xfc47,0xfc47,
0xfc26,0xfc06,0xfbe6,0xfbe6,0xfbc6,0xfba6,0xfb85,0xfb85,0xfb65,
0xfb45,0xfb25,0xfb25,0xfb05,0xfae4,0xfac4,0xfac4,0xfaa4,0xfa84,
0xfa64,0xfa63,0xfa43,0xfa23,0xfa03,0xfa03,0xf9e3,0xf9c3,0xf9a2,
0xf9a2,0xf982,0xf962,0xf942};
#endif
#if colorMode == 2
const PROGMEM uint16_t camColors[] =
{0x002e,0x002e,0x002e,0x002f,0x002f,0x002f,0x002f,0x002f,0x002f,0x004f,0x002f,0x0050,0x0030,
0x0050,0x0030,0x0050,0x0050,0x0051,0x0051,0x0051,0x0051,0x0051,0x0051,0x0051,0x0052,0x0052,
0x0052,0x0052,0x0052,0x0052,0x0052,0x0053,0x0053,0x0053,0x0053,0x0053,0x0053,0x0053,0x0054,
0x0054,0x0054,0x0054,0x0054,0x0054,0x0054,0x0055,0x0055,0x0055,0x0055,0x0055,0x0055,0x0055,
0x0056,0x0056,0x0056,0x0056,0x0056,0x0056,0x0056,0x0057,0x0057,0x0057,0x0057,0x0057,0x0057,
0x0057,0x0058,0x0078,0x0058,0x0078,0x0058,0x0078,0x0058,0x0079,0x0059,0x0079,0x0079,0x0079,
0x0079,0x007a,0x007a,0x007a,0x007a,0x007a,0x007a,0x007a,0x007a,0x007b,0x007b,0x007b,0x007b,
0x007b,0x007b,0x007c,0x007c,0x007c,0x007c,0x007c,0x007c,0x007c,0x007c,0x007d,0x007d,0x007d,
0x007d,0x007d,0x007d,0x007e,0x007e,0x007e,0x007e,0x007e,0x007e,0x007e,0x007f,0x007f,0x007f,
0x007f,0x007f,0x007f,0x007f,0x009f,0x009f,0x009f,0x009f,0x00bf,0x00bf,0x00bf,0x00be,0x00de,
0x00de,0x00de,0x00fe,0x00fe,0x00fd,0x00fd,0x011d,0x011d,0x011d,0x013d,0x013d,0x013d,0x013c,
0x015c,0x015c,0x015c,0x015c,0x017c,0x017c,0x017c,0x017b,0x019b,0x019b,0x019b,0x01bb,0x01bb,
0x01bb,0x01ba,0x01da,0x01da,0x01da,0x01fa,0x01fa,0x01fa,0x01f9,0x0219,0x0219,0x0219,0x0219,
0x0239,0x0239,0x0239,0x0238,0x0258,0x0258,0x0258,0x0258,0x0278,0x0278,0x0277,0x0297,0x0297,
0x0297,0x02b7,0x02b7,0x02b7,0x02b6,0x02d6,0x02d6,0x02d6,0x02d6,0x02f6,0x02f6,0x02f6,0x02f5,
0x0315,0x0315,0x0315,0x0315,0x0335,0x0335,0x0334,0x0354,0x0354,0x0354,0x0374,0x0374,0x0374,
0x0373,0x0393,0x0393,0x0393,0x0393,0x03b3,0x03b3,0x03b3,0x03b2,0x03d2,0x03d2,0x03d2,0x03d2,
0x03f2,0x03f2,0x03f1,0x0411,0x0411,0x0411,0x0411,0x0431,0x0431,0x0430,0x0450,0x0450,0x0450,
0x0450,0x0470,0x0470,0x0470,0x046f,0x048f,0x048f,0x048f,0x048f,0x04af,0x04af,0x04ae,0x04ce,
0x04ce,0x04ce,0x04ce,0x04ee,0x04ee,0x04ed,0x050d,0x050d,0x050d,0x050d,0x052d,0x052d,0x052d,
0x052c,0x054c,0x054c,0x054c,0x054c,0x056c,0x056c,0x056b,0x058b,0x058b,0x058b,0x058b,0x05ab,
0x05ab,0x05aa,0x05ca,0x05ca,0x05ca,0x05ca,0x05ea,0x05ea,0x05ea,0x05e9,0x0609,0x0609,0x0609,
0x0609,0x0629,0x0629,0x0628,0x0648,0x0648,0x0648,0x0648,0x0668,0x0668,0x0667,0x0687,0x0687,
0x0687,0x0687,0x06a7,0x06a7,0x06a7,0x06a6,0x06c6,0x06c6,0x06c6,0x06c6,0x06e6,0x06e6,0x06e5,
0x06e5,0x0705,0x0705,0x0705,0x0725,0x0725,0x0724,0x0744,0x0744,0x0744,0x0744,0x0764,0x0764,
0x0764,0x0763,0x0783,0x0783,0x0783,0x0783,0x07a3,0x07a3,0x07a2,0x07a2,0x07c2,0x07c2,0x07c2,
0x07e2,0x07e2,0x07e1,0x07e1,0x07e1,0x07e1,0x07e1,0x0fe1,0x07e1,0x0fe1,0x0fe1,0x0fe1,0x0fe1,
0x0fe1,0x0fe1,0x0fe1,0x0fe1,0x17e1,0x17e1,0x17e1,0x17e1,0x17e1,0x1fe1,0x17e1,0x1fe1,0x1fe1,
0x1fe1,0x1fe1,0x1fe1,0x27e1,0x27e1,0x27e1,0x27e1,0x27e1,0x27e1,0x27e1,0x27e1,0x2fe1,0x27e1,
0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x37e1,0x37e1,0x37e1,0x37c1,0x37e1,
0x3fc1,0x37e1,0x3fc1,0x3fe1,0x3fc1,0x3fc1,0x47c1,0x47c1,0x47c1,0x47c1,0x47c1,0x47c1,0x47c1,
0x4fc1,0x47c1,0x4fc1,0x47c1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x57c1,
0x57c1,0x57c1,0x5fc1,0x57c1,0x5fc1,0x5fc1,0x5fc1,0x5fc1,0x5fc1,0x67c1,0x67c1,0x67c1,0x67c1,
0x67c1,0x67c1,0x67c1,0x67c1,0x6fc1,0x67c1,0x6fc1,0x67c1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,
0x6fc1,0x6fc1,0x77c1,0x77c1,0x77a0,0x77c1,0x7fa0,0x77c1,0x7fa0,0x7fc1,0x7fa0,0x7fa0,0x7fa0,
0x87a0,0x87a0,0x87a0,0x87a0,0x8fa2,0x8fa2,0x8fa2,0x87a0,0x8fa2,0x87a0,0x8fa2,0x8fa0,0x8fa0,
0x8fa0,0x8fa0,0x8fa0,0x8fa0,0x97a2,0x97a0,0x9fa2,0x97a0,0x9fa2,0x97a0,0x9fa2,0x9fa2,0x9fa2,
0xa7a2,0xa7a2,0xa7a2,0x9fa0,0xa7a2,0x9fa0,0xa7a2,0xa7a0,0xa7a0,0xa7a0,0xa7a0,0xa7a0,0xa7a0,
0xa7a0,0xafa0,0xb7a2,0xafa0,0xb7a2,0xafa0,0xb7a2,0xb7a2,0xb7a2,0xbfa2,0xbfa2,0xbfa2,0xb780,
0xbfa2,0xb780,0xbfa2,0xbf80,0xc7a2,0xbf80,0xbf80,0xbf80,0xbf80,0xbf80,0xc780,0xcf82,0xc780,
0xcf82,0xc780,0xcf82,0xcf82,0xcf82,0xd782,0xd782,0xd782,0xd782,0xd782,0xcf80,0xd782,0xd780,
0xdf82,0xd780,0xd780,0xd780,0xd780,0xd780,0xdf80,0xe782,0xdf80,0xe782,0xdf80,0xe782,0xdf80,
0xe782,0xef82,0xef82,0xef82,0xef82,0xef82,0xe780,0xef82,0xef80,0xf782,0xef80,0xef80,0xef80,
0xef80,0xef80,0xf780,0xf760,0xf780,0xf760,0xf760,0xf760,0xf762,0xf760,0xf762,0xf760,0xf762,
0xf760,0xf762,0xf740,0xf742,0xf742,0xf742,0xf742,0xf742,0xf742,0xf742,0xf742,0xf740,0xf742,
0xf740,0xf722,0xf721,0xf723,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf723,
0xf701,0xf703,0xf701,0xf703,0xf701,0xf703,0xf703,0xf703,0xf703,0xf703,0xf703,0xf703,0xf6e3,
0xf6e1,0xf6e3,0xf6e2,0xf6e4,0xf6e2,0xf6e4,0xf6e2,0xf6e4,0xf6e2,0xf6e2,0xf6e2,0xf6c2,0xf6c2,
0xf6c2,0xf6c2,0xf6c2,0xf6c4,0xf6c2,0xf6c4,0xf6c2,0xf6c4,0xf6c2,0xf6c4,0xf6a4,0xf6a4,0xf6a4,
0xf6a4,0xf6a4,0xf6a5,0xf6a5,0xf6a3,0xf6a5,0xf6a3,0xf685,0xf6a3,0xf685,0xf683,0xf683,0xf683,
0xf683,0xf683,0xf683,0xf683,0xf683,0xf685,0xf663,0xf685,0xf663,0xf665,0xf663,0xf665,0xf663,
0xf665,0xf665,0xf666,0xf666,0xf666,0xf646,0xf646,0xf646,0xfe44,0xf646,0xfe44,0xf646,0xfe44,
0xf646,0xfe44,0xfe44,0xfe44,0xfe24,0xfe24,0xfe24,0xfe24,0xfe24,0xfe26,0xfe24,0xfe26,0xfe24,
0xfe27,0xfe24,0xfe27,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe05,
0xfe07,0xfe05,0xfde7,0xfde5,0xfde7,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,
0xfde8,0xfdc5,0xfdc8,0xfdc6,0xfdc8,0xfdc6,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,
0xfda8,0xfda6,0xfda8,0xfda6,0xfda8,0xfda6,0xfda8,0xfda6,0xfda6,0xfda6,0xfda6,0xfda6,0xfd86,
0xfd87,0xfd86,0xfd87,0xfd87,0xfd89,0xfd87,0xfd89,0xfd87,0xfd89,0xfd67,0xfd89,0xfd69,0xfd69,
0xfd69,0xfd69,0xfd69,0xfd69,0xfd69,0xfd67,0xfd69,0xfd67,0xfd49,0xfd67,0xfd49,0xfd47,0xfd47,
0xfd48,0xfd47,0xfd48,0xfd48,0xfd48,0xfd48,0xfd4a,0xfd28,0xfd2a,0xfd28,0xfd2a,0xfd28,0xfd2a,
0xfd2a,0xfd2a,0xfd2a,0xfd2a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfcea,0xfcea,0xfcea,
0xfcea,0xfcea,0xfcca,0xfcc9,0xfcc9,0xfcc9,0xfcc9,0xfca9,0xfca9,0xfca9,0xfca9,0xfca9,0xfca9,
0xfc89,0xfc89,0xfc89,0xfc89,0xfc89,0xfc69,0xfc69,0xfc69,0xfc69,0xfc69,0xfc49,0xfc49,0xfc49,
0xfc49,0xfc49,0xfc49,0xfc28,0xfc28,0xfc28,0xfc28,0xfc28,0xfc08,0xfc08,0xfc08,0xfc08,0xfc08,
0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfba8,0xfba8,
0xfba8,0xfba8,0xfba8,0xfb87,0xfb87,0xfb87,0xfb87,0xfb87,0xfb87,0xfb67,0xfb67,0xfb67,0xfb67,
0xfb67,0xfb47,0xfb47,0xfb47,0xfb47,0xfb47,0xfb27,0xfb27,0xfb27,0xfb27,0xfb27,0xfb27,0xfb07,
0xfb07,0xfb07,0xfb07,0xfb06,0xfae6,0xfae6,0xfae6,0xfae6,0xfae6,0xfac6,0xfac6,0xfac6,0xfac6,
0xfac6,0xfac6,0xfaa6,0xfaa6,0xfaa6,0xfaa6,0xfaa6,0xfa86,0xfa86,0xfa86,0xfa86,0xfa86,0xfa66,
0xfa66,0xfa66,0xfa66,0xfa65,0xfa65,0xfa45,0xfa45,0xfa45,0xfa45,0xfa45,0xfa25,0xfa25,0xfa25,
0xfa25,0xfa25,0xfa05,0xfa05,0xfa05,0xfa05,0xfa05,0xfa05,0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xf9e5,
0xf9e5,0xf9c5,0xf9c5,0xf9c4,0xf9c4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf984,0xf984,
0xf984,0xf984,0xf984,0xf984,0xf964,0xf964,0xf964,0xf964,0xf944,0xf944,0xf944,0xf944,0xf944,
0xf944,0xf924,0xf924,0xf923,0xf923,0xf923,0xf923,0xf903,0xf903,0xf903,0xf903,0xf8e3,0xf8e3,
0xf8e3,0xf8e3,0xf8e3,0xf8e3,0xf8c3,0xf8c3,0xf8c3,0xf8c3,0xf8c3,0xf8c3,0xf8a3,0xf8a3,0xf8a3,
0xf8a3,0xf883,0xf883,0xf882,0xf882,0xf882,0xf882,0xf862,0xf862,0xf862,0xf862,0xf862,0xf862,
0xf842,0xf842,0xf842,0xf842,0xf822,0xf822,0xf822,0xf822,0xf822,0xf822,0xf802,0xf802,0xf802,
0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,
0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802};
#endif
#if colorMode == 21  //this is alternate color map 
/* from https://www.thingiverse.com/thing:3017556
1st
#000000
 2nd
#000fff
 3rd
#00ff0f
 4th
#ff0000
 5th
#FfA544
 6th
#F0F000
 */
const PROGMEM uint16_t camColors[] =
{0x002e,0x002e,0x002e,0x002f,0x002f,0x002f,0x002f,0x002f,0x002f,0x004f,0x002f,0x0050,0x0030,
0x0050,0x0030,0x0050,0x0050,0x0051,0x0051,0x0051,0x0051,0x0051,0x0051,0x0051,0x0052,0x0052,
0x0052,0x0052,0x0052,0x0052,0x0052,0x0053,0x0053,0x0053,0x0053,0x0053,0x0053,0x0053,0x0054,
0x0054,0x0054,0x0054,0x0054,0x0054,0x0054,0x0055,0x0055,0x0055,0x0055,0x0055,0x0055,0x0055,
0x0056,0x0056,0x0056,0x0056,0x0056,0x0056,0x0056,0x0057,0x0057,0x0057,0x0057,0x0057,0x0057,
0x0057,0x0058,0x0078,0x0058,0x0078,0x0058,0x0078,0x0058,0x0079,0x0059,0x0079,0x0079,0x0079,
0x0079,0x007a,0x007a,0x007a,0x007a,0x007a,0x007a,0x007a,0x007a,0x007b,0x007b,0x007b,0x007b,
0x007b,0x007b,0x007c,0x007c,0x007c,0x007c,0x007c,0x007c,0x007c,0x007c,0x007d,0x007d,0x007d,
0x007d,0x007d,0x007d,0x007e,0x007e,0x007e,0x007e,0x007e,0x007e,0x007e,0x007f,0x007f,0x007f,
0x007f,0x007f,0x007f,0x007f,0x009f,0x009f,0x009f,0x009f,0x00bf,0x00bf,0x00bf,0x00be,0x00de,
0x00de,0x00de,0x00fe,0x00fe,0x00fd,0x00fd,0x011d,0x011d,0x011d,0x013d,0x013d,0x013d,0x013c,
0x015c,0x015c,0x015c,0x015c,0x017c,0x017c,0x017c,0x017b,0x019b,0x019b,0x019b,0x01bb,0x01bb,
0x01bb,0x01ba,0x01da,0x01da,0x01da,0x01fa,0x01fa,0x01fa,0x01f9,0x0219,0x0219,0x0219,0x0219,
0x0239,0x0239,0x0239,0x0238,0x0258,0x0258,0x0258,0x0258,0x0278,0x0278,0x0277,0x0297,0x0297,
0x0297,0x02b7,0x02b7,0x02b7,0x02b6,0x02d6,0x02d6,0x02d6,0x02d6,0x02f6,0x02f6,0x02f6,0x02f5,
0x0315,0x0315,0x0315,0x0315,0x0335,0x0335,0x0334,0x0354,0x0354,0x0354,0x0374,0x0374,0x0374,
0x0373,0x0393,0x0393,0x0393,0x0393,0x03b3,0x03b3,0x03b3,0x03b2,0x03d2,0x03d2,0x03d2,0x03d2,
0x03f2,0x03f2,0x03f1,0x0411,0x0411,0x0411,0x0411,0x0431,0x0431,0x0430,0x0450,0x0450,0x0450,
0x0450,0x0470,0x0470,0x0470,0x046f,0x048f,0x048f,0x048f,0x048f,0x04af,0x04af,0x04ae,0x04ce,
0x04ce,0x04ce,0x04ce,0x04ee,0x04ee,0x04ed,0x050d,0x050d,0x050d,0x050d,0x052d,0x052d,0x052d,
0x052c,0x054c,0x054c,0x054c,0x054c,0x056c,0x056c,0x056b,0x058b,0x058b,0x058b,0x058b,0x05ab,
0x05ab,0x05aa,0x05ca,0x05ca,0x05ca,0x05ca,0x05ea,0x05ea,0x05ea,0x05e9,0x0609,0x0609,0x0609,
0x0609,0x0629,0x0629,0x0628,0x0648,0x0648,0x0648,0x0648,0x0668,0x0668,0x0667,0x0687,0x0687,
0x0687,0x0687,0x06a7,0x06a7,0x06a7,0x06a6,0x06c6,0x06c6,0x06c6,0x06c6,0x06e6,0x06e6,0x06e5,
0x06e5,0x0705,0x0705,0x0705,0x0725,0x0725,0x0724,0x0744,0x0744,0x0744,0x0744,0x0764,0x0764,
0x0764,0x0763,0x0783,0x0783,0x0783,0x0783,0x07a3,0x07a3,0x07a2,0x07a2,0x07c2,0x07c2,0x07c2,
0x07e2,0x07e2,0x07e1,0x07e1,0x07e1,0x07e1,0x07c1,0x07c1,0x07c1,0x07c1,0x0fa1,0x0fa1,0x0fa1,
0x1781,0x0f81,0x1781,0x1761,0x1761,0x1761,0x1761,0x1f41,0x1741,0x1741,0x1f41,0x1f21,0x1f21,
0x1f21,0x2701,0x2701,0x2701,0x26e1,0x26e1,0x26e1,0x26e1,0x26c1,0x26c1,0x26c1,0x2ea1,0x2ea1,
0x2ea1,0x2e81,0x3681,0x3681,0x2e81,0x3661,0x3661,0x3661,0x3661,0x3641,0x3641,0x3641,0x3e21,
0x3e21,0x3e21,0x3e01,0x4601,0x4601,0x3e01,0x45e1,0x45e1,0x45e1,0x45e1,0x45c1,0x4dc1,0x45c1,
0x4da1,0x4da1,0x4da1,0x4d81,0x4d81,0x5581,0x4d81,0x5561,0x5561,0x5561,0x5d41,0x5541,0x5d41,
0x5541,0x5d21,0x6523,0x6523,0x6503,0x6503,0x5d01,0x6503,0x64e1,0x64e1,0x64e1,0x64c1,0x6cc3,
0x64c1,0x6ca3,0x74a3,0x74a3,0x74a3,0x6c81,0x7483,0x6c81,0x7481,0x7461,0x7461,0x7461,0x7441,
0x7c43,0x7441,0x7c23,0x8423,0x8422,0x8423,0x7c00,0x8403,0x7c00,0x8401,0x83e0,0x83e0,0x8be2,
0x83c0,0x8bc2,0x8bc2,0x8ba2,0x93a2,0x8ba0,0x93a2,0x8b80,0x8b80,0x8b80,0x9360,0x9b62,0x9360,
0x9b42,0x9340,0x9b42,0x9b42,0x9b22,0xa322,0x9b20,0xa322,0x9b00,0x9b00,0x9b00,0xa2e0,0xaae2,
0xa2e0,0xaac2,0xaac2,0xaac2,0xaac2,0xaaa0,0xb2a2,0xaaa0,0xaaa0,0xaa80,0xaa80,0xb282,0xb260,
0xba62,0xba62,0xba42,0xba42,0xb240,0xba42,0xba20,0xc222,0xba20,0xba00,0xba00,0xba00,0xc1e2,
0xc1e0,0xc9e2,0xc9e2,0xc9c2,0xc9c2,0xc1c0,0xc9c2,0xc9a0,0xc9a0,0xc9a0,0xc980,0xd182,0xc980,
0xd162,0xd962,0xd962,0xd962,0xd140,0xd942,0xd140,0xd940,0xd920,0xd920,0xe122,0xd900,0xe102,
0xd900,0xe0e2,0xe8e2,0xe8e2,0xe8e2,0xe0c0,0xe8c2,0xe0c0,0xe8c0,0xe8a0,0xe8a0,0xf0a2,0xe880,
0xf082,0xf082,0xf062,0xf062,0xf060,0xf062,0xf040,0xf040,0xf040,0xf820,0xf822,0xf820,0xf802,
0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf822,0xf822,0xf822,0xf822,0xf822,
0xf842,0xf842,0xf842,0xf842,0xf842,0xf862,0xf862,0xf862,0xf862,0xf862,0xf862,0xf882,0xf882,
0xf882,0xf882,0xf883,0xf8a3,0xf8a3,0xf8a3,0xf8a3,0xf8a3,0xf8c3,0xf8c3,0xf8c3,0xf8c3,0xf8c3,
0xf8c3,0xf8e3,0xf8e3,0xf8e3,0xf8e3,0xf8e3,0xf903,0xf903,0xf903,0xf903,0xf903,0xf923,0xf923,
0xf923,0xf923,0xf924,0xf924,0xf944,0xf944,0xf944,0xf944,0xf944,0xf964,0xf964,0xf964,0xf964,
0xf964,0xf984,0xf984,0xf984,0xf984,0xf984,0xf984,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf9c4,
0xf9c4,0xf9c4,0xf9c5,0xf9c5,0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xfa05,0xfa05,0xfa05,
0xfa05,0xfa05,0xfa25,0xfa25,0xfa25,0xfa25,0xfa25,0xfa45,0xfa45,0xfa45,0xfa45,0xfa45,0xfa45,
0xfa65,0xfa65,0xfa66,0xfa66,0xfa66,0xfa66,0xfa86,0xfa86,0xfa86,0xfa86,0xfaa6,0xfaa6,0xfaa6,
0xfaa6,0xfaa6,0xfaa6,0xfac6,0xfac6,0xfac6,0xfac6,0xfac6,0xfac6,0xfae6,0xfae6,0xfae6,0xfae6,
0xfb07,0xfb06,0xfb07,0xfb07,0xfb07,0xfb07,0xfb27,0xfb27,0xfb27,0xfb27,0xfb27,0xfb27,0xfb47,
0xfb47,0xfb47,0xfb47,0xfb67,0xfb67,0xfb67,0xfb67,0xfb67,0xfb67,0xfb87,0xfb87,0xfb87,0xfb87,
0xfb88,0xfb87,0xfba8,0xfba8,0xfba8,0xfba8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfbe8,
0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfc08,0xfc08,0xfc08,0xfc08,0xfc28,0xfc28,0xfc28,0xfc28,
0xfc29,0xfc28,0xfc49,0xfc49,0xfc49,0xfc49,0xfc49,0xfc49,0xfc69,0xfc69,0xfc69,0xfc69,0xfc89,
0xfc89,0xfc89,0xfc89,0xfc89,0xfc89,0xfca9,0xfca9,0xfca9,0xfca9,0xfca9,0xfca9,0xfcc9,0xfcc9,
0xfcca,0xfcc9,0xfcea,0xfcea,0xfcea,0xfcea,0xfcea,0xfcea,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,
0xfd0a,0xfd2a,0xfd2a,0xfd2a,0xfd28,0xfd2a,0xfd28,0xfd2a,0xfd28,0xfd4a,0xfd28,0xfd4a,0xfd48,
0xfd48,0xfd48,0xfd48,0xfd47,0xfd47,0xfd47,0xfd47,0xfd49,0xfd67,0xfd49,0xfd67,0xfd69,0xfd67,
0xfd69,0xfd69,0xfd69,0xfd69,0xfd69,0xfd69,0xfd69,0xfd89,0xfd87,0xfd89,0xfd87,0xfd89,0xfd87,
0xfd89,0xfd87,0xfd87,0xfd86,0xfd86,0xfd86,0xfda6,0xfda6,0xfda6,0xfda8,0xfda6,0xfda8,0xfda6,
0xfda8,0xfda6,0xfda8,0xfda6,0xfda8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc8,0xfdc6,
0xfdc8,0xfdc6,0xfdc8,0xfdc5,0xfde7,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,0xfde5,
0xfde7,0xfde5,0xfde7,0xfe05,0xfe07,0xfe05,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,0xfe07,
0xfe07,0xfe05,0xfe27,0xfe24,0xfe26,0xfe24,0xfe26,0xfe24,0xfe26,0xfe24,0xfe24,0xfe24,0xfe44,
0xfe24,0xfe44,0xfe44,0xfe44,0xf646,0xfe44,0xf646,0xfe44,0xf646,0xfe44,0xf646,0xf666,0xf646,
0xf666,0xf666,0xf666,0xf665,0xf665,0xf663,0xf665,0xf663,0xf665,0xf663,0xf685,0xf683,0xf683,
0xf683,0xf683,0xf683,0xf683,0xf683,0xf683,0xf685,0xf683,0xf685,0xf6a3,0xf6a5,0xf6a3,0xf6a5,
0xf6a3,0xf6a5,0xf6a5,0xf6a4,0xf6a4,0xf6a4,0xf6a4,0xf6a4,0xf6c4,0xf6c2,0xf6c4,0xf6c2,0xf6c4,
0xf6c2,0xf6c4,0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6e2,0xf6e2,0xf6e2,0xf6e4,0xf6e2,0xf6e4,
0xf6e2,0xf6e4,0xf6e2,0xf6e3,0xf6e3,0xf6e3,0xf703,0xf703,0xf703,0xf703,0xf703,0xf703,0xf703,
0xf701,0xf703,0xf701,0xf703,0xf701,0xf723,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,
0xf721,0xf723,0xf721,0xf722,0xf740,0xf742,0xf740,0xf742,0xf742,0xf742,0xf742,0xf742,0xf742,
0xf742,0xf762,0xf740,0xf762,0xf760,0xf762,0xf760,0xf762,0xf760,0xf760,0xf760,0xf760,0xf760,
0xf780,0xf760,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780};
#endif

#if colorMode == 22  //this is alternate color map with shades of grey except for hot areas
/* from https://www.thingiverse.com/thing:3017556
1st
#000000
 2nd
#AAAAAA
 3rd
#CCCCCC
 4th
#FFFFFF
 5th
#FfA544
 6th
#FF0000
 */
const PROGMEM uint16_t camColors[] = 
{0x4a69,0x4a69,0x4a69,0x528a,0x528a,0x528a,0x528a,0x528a,0x528a,0x52aa,0x52aa,0x52aa,0x52aa,0x5acb,0x5acb,0x5acb,0x5acb,
0x5acb,0x5acb,0x5aeb,0x5aeb,0x5aeb,0x5aeb,0x5aeb,0x630c,0x630c,0x630c,0x630c,0x630c,0x632c,0x632c,0x632c,0x632c,0x632c,
0x632c,0x6b4d,0x6b4d,0x6b4d,0x6b4d,0x6b6d,0x6b6d,0x6b6d,0x6b6d,0x6b6d,0x6b6d,0x738e,0x738e,0x738e,0x738e,0x738e,0x73ae,
0x73ae,0x73ae,0x73ae,0x73ae,0x7bcf,0x7bcf,0x7bcf,0x7bcf,0x7bcf,0x7bcf,0x7bef,0x7bef,0x7bef,0x7bef,0x8410,0x8410,0x8410,
0x8410,0x8410,0x8410,0x8430,0x8430,0x8430,0x8430,0x8430,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c71,0x8c71,0x8c71,0x8c71,
0x8c71,0x8c71,0x9492,0x9492,0x9492,0x9492,0x94b2,0x94b2,0x94b2,0x94b2,0x94b2,0x94b2,0x9cd3,0x9cd3,0x9cd3,0x9cd3,0x9cd3,
0x9cf3,0x9cf3,0x9cf3,0x9cf3,0x9cf3,0xa514,0xa514,0xa514,0xa514,0xa514,0xa514,0xa534,0xa534,0xa534,0xa534,0xad55,0xad55,
0xad55,0xad55,0xad55,0xad55,0xad55,0xad55,0xad55,0xad55,0xad55,0xad55,0xad75,0xad55,0xad75,0xad55,0xad75,0xad75,0xad75,
0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,0xad75,
0xad75,0xad75,0xb596,0xad75,0xb596,0xad75,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,
0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb596,0xb5b6,0xb596,0xb5b6,0xb596,0xb5b6,0xb5b6,
0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,0xb5b6,
0xb5b6,0xb5b6,0xb5b6,0xbdd7,0xb5b6,0xbdd7,0xb5b6,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,
0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdd7,0xbdf7,0xbdd7,0xbdf7,0xbdd7,0xbdf7,
0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xbdf7,
0xbdf7,0xbdf7,0xbdf7,0xbdf7,0xc618,0xbdf7,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,
0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc618,0xc638,0xc618,0xc638,0xc638,
0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,0xc638,
0xc638,0xc638,0xc638,0xc638,0xc638,0xce59,0xc638,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,
0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce59,0xce79,0xce59,0xce79,
0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,0xce79,
0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd69a,0xd6ba,
0xd69a,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,0xd6ba,
0xdedb,0xd6ba,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,0xdedb,
0xdedb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,0xdefb,
0xe71c,0xdefb,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,0xe71c,
0xe71c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,0xe73c,
0xe73c,0xe73c,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,0xef5d,
0xef5d,0xef7d,0xef5d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,0xef7d,
0xef7d,0xef7d,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,0xf79e,
0xf79e,0xf7be,0xf79e,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,0xf7be,
0xf7be,0xf7be,0xffdf,0xf7be,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,0xffdf,
0xffdf,0xffdf,0xffdf,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,
0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffde,0xffde,0xffde,0xffde,0xffde,0xffde,0xffde,0xffde,
0xffde,0xffde,0xffbf,0xffbf,0xffbf,0xffbf,0xffbf,0xffbf,0xffbf,0xffbf,0xffbf,0xffbf,0xff9e,0xff9e,0xff9e,0xff9e,0xff9e,
0xff9e,0xff9e,0xff9e,0xff9d,0xff9d,0xff7d,0xff7d,0xff7d,0xff7d,0xff7d,0xff7d,0xff7d,0xff7d,0xff7c,0xff7c,0xff5c,0xff5c,
0xff5c,0xff5c,0xff5c,0xff5c,0xff5c,0xff5c,0xff3b,0xff5b,0xff3b,0xff3b,0xff3b,0xff3b,0xff3b,0xff3b,0xff3b,0xff3a,0xff1a,
0xff1a,0xff1a,0xff1a,0xff1a,0xff1a,0xff1a,0xff1a,0xff19,0xff19,0xfef9,0xfef9,0xfef9,0xfef9,0xfef9,0xfef9,0xfef9,0xfef9,
0xfef8,0xfef8,0xfed8,0xfed8,0xfed8,0xfed8,0xfed8,0xfed8,0xfed8,0xfed8,0xfed7,0xfed7,0xfeb7,0xfeb7,0xfeb7,0xfeb7,0xfeb7,
0xfeb7,0xfeb7,0xfeb6,0xfeb6,0xfeb6,0xfe96,0xfe96,0xfe96,0xfe96,0xfe96,0xfe96,0xfe95,0xfe95,0xfe95,0xfe95,0xfe75,0xfe75,
0xfe75,0xfe75,0xfe75,0xfe75,0xfe74,0xfe74,0xfe74,0xfe74,0xfe54,0xfe54,0xfe54,0xfe54,0xfe54,0xfe53,0xfe53,0xfe53,0xfe53,
0xfe53,0xfe33,0xfe33,0xfe33,0xfe33,0xfe32,0xfe32,0xfe32,0xfe32,0xfe32,0xfe32,0xfe12,0xfe12,0xfe12,0xfe12,0xfe11,0xfe11,
0xfe11,0xfe11,0xfdf1,0xfe11,0xfdf1,0xfdf1,0xfdf1,0xfdf1,0xfdf0,0xfdf0,0xfdf0,0xfdf0,0xfdd0,0xfdd0,0xfdd0,0xfdd0,0xfdd0,
0xfdcf,0xfdcf,0xfdcf,0xfdcf,0xfdcf,0xfdaf,0xfdaf,0xfdaf,0xfdaf,0xfdae,0xfdae,0xfdae,0xfdae,0xfdae,0xfdae,0xfd8e,0xfd8e,
0xfd8e,0xfd8e,0xfd8d,0xfd8d,0xfd8d,0xfd8d,0xfd8d,0xfd8d,0xfd6d,0xfd6d,0xfd6d,0xfd6c,0xfd6c,0xfd6c,0xfd6c,0xfd6c,0xfd6c,
0xfd6c,0xfd4c,0xfd4c,0xfd4b,0xfd4b,0xfd4b,0xfd4b,0xfd4b,0xfd4b,0xfd4b,0xfd4b,0xfd2b,0xfd2b,0xfd2a,0xfd2a,0xfd2a,0xfd2a,
0xfd2a,0xfd2a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfd0a,0xfcea,0xfcea,0xfcea,0xfcea,0xfcea,0xfcca,0xfcc9,0xfcc9,0xfcc9,
0xfcc9,0xfca9,0xfca9,0xfca9,0xfca9,0xfca9,0xfca9,0xfc89,0xfc89,0xfc89,0xfc89,0xfc89,0xfc69,0xfc69,0xfc69,0xfc69,0xfc69,
0xfc49,0xfc49,0xfc49,0xfc49,0xfc49,0xfc49,0xfc28,0xfc28,0xfc28,0xfc28,0xfc28,0xfc08,0xfc08,0xfc08,0xfc08,0xfc08,0xfbe8,
0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfbe8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfbc8,0xfba8,0xfba8,0xfba8,0xfba8,0xfba8,0xfb87,0xfb87,
0xfb87,0xfb87,0xfb87,0xfb87,0xfb67,0xfb67,0xfb67,0xfb67,0xfb67,0xfb47,0xfb47,0xfb47,0xfb47,0xfb47,0xfb27,0xfb27,0xfb27,
0xfb27,0xfb27,0xfb27,0xfb07,0xfb07,0xfb07,0xfb07,0xfb06,0xfae6,0xfae6,0xfae6,0xfae6,0xfae6,0xfac6,0xfac6,0xfac6,0xfac6,
0xfac6,0xfac6,0xfaa6,0xfaa6,0xfaa6,0xfaa6,0xfaa6,0xfa86,0xfa86,0xfa86,0xfa86,0xfa86,0xfa66,0xfa66,0xfa66,0xfa66,0xfa65,
0xfa65,0xfa45,0xfa45,0xfa45,0xfa45,0xfa45,0xfa25,0xfa25,0xfa25,0xfa25,0xfa25,0xfa05,0xfa05,0xfa05,0xfa05,0xfa05,0xfa05,
0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xf9e5,0xf9c5,0xf9c5,0xf9c4,0xf9c4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf9a4,0xf984,
0xf984,0xf984,0xf984,0xf984,0xf984,0xf964,0xf964,0xf964,0xf964,0xf944,0xf944,0xf944,0xf944,0xf944,0xf944,0xf924,0xf924,
0xf923,0xf923,0xf923,0xf923,0xf903,0xf903,0xf903,0xf903,0xf8e3,0xf8e3,0xf8e3,0xf8e3,0xf8e3,0xf8e3,0xf8c3,0xf8c3,0xf8c3,
0xf8c3,0xf8c3,0xf8c3,0xf8a3,0xf8a3,0xf8a3,0xf8a3,0xf883,0xf883,0xf882,0xf882,0xf882,0xf882,0xf862,0xf862,0xf862,0xf862,
0xf862,0xf862,0xf842,0xf842,0xf842,0xf842,0xf822,0xf822,0xf822,0xf822,0xf822,0xf822,0xf802,0xf802,0xf802,0xf802,0xf802,
0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,0xf802,
0xf802,0xf802,0xf802,0xf802};
#endif

#if colorMode == 23  //this is alternate color map with shades of grey except for hot areas
/* from https://www.thingiverse.com/thing:3017556
1st
#0000ff
 2nd
#00ff0f
 3rd
#F0F000
 4th
#F0F000
 5th
#660000
 6th
#ff0000
 */
const PROGMEM uint16_t camColors[] = 
{0x00fc,0x00fc,0x011c,0x011c,0x011b,0x011b,0x013b,0x013b,0x013b,0x015b,0x015b,0x015a,0x015a,0x017a,0x017a,0x017a,
0x019a,0x019a,0x019a,0x0199,0x01b9,0x01b9,0x01b9,0x01d9,0x01d9,0x01d9,0x01f8,0x01f8,0x01f8,0x01f8,0x0218,0x0218,
0x0218,0x0217,0x0237,0x0237,0x0237,0x0257,0x0257,0x0257,0x0277,0x0276,0x0276,0x0276,0x0296,0x0296,0x0296,0x0296,
0x02b5,0x02b5,0x02b5,0x02d5,0x02d5,0x02d5,0x02f5,0x02f4,0x02f4,0x02f4,0x0314,0x0314,0x0314,0x0334,0x0334,0x0333,
0x0353,0x0353,0x0353,0x0353,0x0373,0x0373,0x0372,0x0372,0x0392,0x0392,0x0392,0x03b2,0x03b2,0x03b1,0x03d1,0x03d1,
0x03d1,0x03d1,0x03f1,0x03f1,0x03f1,0x03f0,0x0410,0x0410,0x0410,0x0430,0x0430,0x0430,0x044f,0x044f,0x044f,0x044f,
0x046f,0x046f,0x046f,0x048e,0x048e,0x048e,0x04ae,0x04ae,0x04ae,0x04ae,0x04ce,0x04cd,0x04cd,0x04cd,0x04ed,0x04ed,
0x04ed,0x050d,0x050c,0x050c,0x052c,0x052c,0x052c,0x052c,0x054c,0x054b,0x054b,0x054b,0x056b,0x056b,0x056b,0x058b,
0x058b,0x058a,0x05aa,0x05aa,0x05aa,0x05aa,0x05ca,0x05ca,0x05c9,0x05c9,0x05e9,0x05e9,0x05e9,0x0609,0x0609,0x0608,
0x0628,0x0628,0x0628,0x0628,0x0648,0x0648,0x0648,0x0667,0x0667,0x0667,0x0687,0x0687,0x0687,0x0687,0x06a6,0x06a6,
0x06a6,0x06a6,0x06c6,0x06c6,0x06c6,0x06e5,0x06e5,0x06e5,0x0705,0x0705,0x0705,0x0705,0x0725,0x0724,0x0724,0x0724,
0x0744,0x0744,0x0744,0x0764,0x0764,0x0763,0x0783,0x0783,0x0783,0x0783,0x07a3,0x07a2,0x07a2,0x07c2,0x07c2,0x07c2,
0x07e2,0x07e2,0x07e2,0x07e1,0x07e1,0x07e1,0x07e1,0x07e1,0x0fe1,0x07e1,0x0fe1,0x0fe1,0x0fe1,0x0fe1,0x0fe1,0x0fe1,
0x0fe1,0x0fe1,0x17e1,0x17e1,0x17e1,0x17e1,0x17e1,0x1fe1,0x17e1,0x1fe1,0x1fe1,0x1fe1,0x1fe1,0x27e1,0x27e1,0x27e1,
0x27e1,0x27e1,0x27e1,0x27e1,0x2fe1,0x27e1,0x2fe1,0x27e1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,0x2fe1,
0x37e1,0x37e1,0x37e1,0x3fc1,0x37e1,0x3fc1,0x3fe1,0x3fc1,0x3fe1,0x3fc1,0x47c1,0x47c1,0x47c1,0x47c1,0x47c1,0x47c1,
0x47c1,0x47c1,0x4fc1,0x47c1,0x4fc1,0x47c1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x4fc1,0x57c1,0x57c1,0x57c1,
0x57c1,0x5fc1,0x57c1,0x5fc1,0x5fc1,0x5fc1,0x5fc1,0x5fc1,0x67c1,0x67c1,0x67c1,0x67c1,0x67c1,0x67c1,0x67c1,0x67c1,
0x6fc1,0x67c1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,0x6fc1,0x77c1,0x77c1,0x77c1,0x77a0,0x77c1,0x7fa0,
0x77c1,0x7fa0,0x7fc1,0x7fa0,0x7fa0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,0x87a0,
0x8fa0,0x97a2,0x8fa0,0x97a2,0x8fa0,0x97a2,0x97a2,0x97a2,0x9fa2,0x9fa2,0x9fa2,0x97a0,0x9fa2,0x97a0,0x9fa2,0x9fa0,
0xa7a2,0x9fa0,0x9fa0,0x9fa0,0x9fa0,0x9fa0,0xa7a0,0xafa2,0xa7a0,0xafa2,0xa7a0,0xafa2,0xafa2,0xafa2,0xb7a2,0xb7a2,
0xb7a2,0xb7a2,0xb7a2,0xafa0,0xb7a2,0xb7a0,0xbfa2,0xb780,0xb7a0,0xb780,0xb7a0,0xb780,0xbfa0,0xc782,0xbfa0,0xc782,
0xbf80,0xc782,0xbf80,0xc782,0xcf82,0xcf82,0xcf82,0xcf82,0xcf82,0xc780,0xcf82,0xcf80,0xd782,0xcf80,0xcf80,0xcf80,
0xcf80,0xcf80,0xd780,0xd780,0xd780,0xdf82,0xd780,0xdf82,0xd780,0xdf82,0xe782,0xe782,0xe782,0xe782,0xe782,0xdf80,
0xe782,0xe780,0xef82,0xe780,0xef82,0xe780,0xe780,0xe780,0xef80,0xef80,0xef80,0xf782,0xef80,0xf782,0xef80,0xf782,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,
0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf780,0xf762,0xf762,0xef60,
0xef60,0xf742,0xf742,0xf742,0xf742,0xef20,0xef20,0xf722,0xf702,0xef00,0xef00,0xe700,0xe6e0,0xeee2,0xeee2,0xe6c0,
0xe6c0,0xeec2,0xeec2,0xeea2,0xeea2,0xe6a0,0xe6a0,0xe682,0xe682,0xde80,0xde80,0xde60,0xde60,0xe662,0xe642,0xde40,
0xde40,0xe642,0xde20,0xde22,0xde22,0xd600,0xd600,0xde02,0xde02,0xd5e0,0xdde2,0xd5e0,0xd5e0,0xddc2,0xddc2,0xd5c0,
0xd5c0,0xd5a2,0xcda0,0xd5a2,0xd582,0xcd80,0xcd80,0xd582,0xd562,0xcd60,0xd562,0xcd40,0xcd40,0xcd42,0xcd42,0xc520,
0xc520,0xcd22,0xc520,0xcd02,0xcd02,0xc500,0xc500,0xcce2,0xcce2,0xc4e0,0xc4e2,0xbcc0,0xbcc0,0xc4c2,0xc4a2,0xbca0,
0xbca0,0xc482,0xbc80,0xc482,0xc482,0xbc60,0xbc60,0xbc62,0xbc62,0xb440,0xbc42,0xb440,0xb440,0xbc22,0xbc22,0xb420,
0xb420,0xbc02,0xb400,0xb402,0xb3e2,0xabe0,0xabe0,0xb3c2,0xb3c2,0xabc0,0xb3c2,0xaba0,0xaba0,0xb3a2,0xb3a2,0xab80,
0xab80,0xab82,0xa380,0xab62,0xab62,0xa360,0xa360,0xab42,0xab42,0xa340,0xab22,0xa320,0xa320,0xa322,0xa302,0x9b00,
0x9b00,0xa2e2,0x9ae0,0xa2e2,0xa2e2,0x9ac0,0x9ac0,0xa2c2,0xa2c2,0x9aa0,0x9aa2,0x92a0,0x92a0,0x9a82,0x9a82,0x9280,
0x9260,0x9a62,0x9260,0x9a62,0x9a42,0x9240,0x9240,0x9222,0x9222,0x8a20,0x9222,0x8a00,0x8a00,0x9202,0x9202,0x89e0,
0x89e0,0x91e2,0x89e0,0x89c2,0x89c2,0x81c0,0x81a0,0x89a2,0x89a2,0x81a0,0x8982,0x8180,0x8180,0x8962,0x8962,0x8160,
0x8160,0x8142,0x7940,0x8142,0x8142,0x7920,0x7920,0x8122,0x8122,0x7900,0x8102,0x7900,0x78e0,0x78e2,0x78e2,0x70e0,
0x70c0,0x78c2,0x70c0,0x78a2,0x78a2,0x70a0,0x70a0,0x7882,0x7882,0x7080,0x7082,0x6860,0x6860,0x7062,0x7062,0x6840,
0x6840,0x7042,0x6840,0x7022,0x7022,0x6820,0x6800,0x6802,0x6802,0x6000,0x6802,0x6802,0x6800,0x7002,0x6800,0x6800,
0x7002,0x7002,0x6800,0x7002,0x6800,0x6800,0x7002,0x7002,0x7802,0x7802,0x7000,0x7000,0x7802,0x7000,0x7802,0x7802,
0x7000,0x7000,0x7800,0x7800,0x8002,0x8002,0x7800,0x8002,0x7800,0x7800,0x8002,0x8002,0x8002,0x8002,0x8000,0x8000,
0x8802,0x8802,0x8802,0x8802,0x8000,0x8000,0x8802,0x8000,0x8802,0x8802,0x8800,0x8800,0x8800,0x8800,0x9002,0x9002,
0x8800,0x9002,0x8800,0x8800,0x9002,0x9002,0x9802,0x9802,0x9000,0x9000,0x9802,0x9000,0x9802,0x9802,0x9000,0x9000,
0x9800,0x9800,0xa002,0xa002,0x9800,0x9800,0x9800,0x9800,0xa002,0xa002,0x9800,0xa002,0xa000,0xa000,0xa802,0xa802,
0xa802,0xa802,0xa000,0xa000,0xa802,0xa000,0xa802,0xa802,0xa800,0xa800,0xa800,0xa800,0xb002,0xb002,0xa800,0xb002,
0xa800,0xa800,0xb002,0xb002,0xb000,0xb802,0xb000,0xb000,0xb802,0xb802,0xb802,0xb802,0xb000,0xb000,0xb802,0xb800,
0xc002,0xc002,0xb800,0xb800,0xb800,0xb800,0xc002,0xc002,0xb800,0xc002,0xc000,0xc000,0xc802,0xc802,0xc802,0xc802,
0xc000,0xc000,0xc802,0xc802,0xc802,0xc802,0xc800,0xc800,0xd002,0xc800,0xd002,0xd002,0xc800,0xc800,0xc800,0xc800,
0xd002,0xd002,0xd000,0xd802,0xd000,0xd000,0xd802,0xd802,0xd802,0xd802,0xd000,0xd000,0xd802,0xd800,0xe002,0xe002,};
#endif
# if colorMode == 3 //this is not implimented in code yet, as display currentlty used is only 12,16,18bit. this is 24 bit data
const PROGMEM uint32_t camColors[] =
{0x00021c,0x00011d,0x00021e,0x00021f,0x000220,0x000221,0x000223,0x000223,0x000225,0x000226,0x000326,0x000228,0x000328,
0x00022a,0x00032b,0x00022c,0x00032d,0x00032e,0x00032f,0x000330,0x000332,0x000332,0x000334,0x000335,0x000336,0x000337,
0x000438,0x000339,0x00043a,0x00033c,0x00043c,0x00033e,0x00043f,0x00043f,0x000441,0x000442,0x000443,0x000444,0x000446,
0x000446,0x000547,0x000449,0x000549,0x00044b,0x00054b,0x00044d,0x00054e,0x00054e,0x000550,0x000551,0x000552,0x000553,
0x000555,0x000555,0x000656,0x000558,0x000658,0x00055a,0x00065b,0x00055c,0x00065d,0x00065e,0x00065f,0x000660,0x000662,
0x000662,0x000664,0x000665,0x000666,0x000667,0x000768,0x000669,0x00076a,0x00066b,0x00076c,0x00066e,0x00076e,0x00076f,
0x000771,0x000771,0x000773,0x000774,0x000775,0x000776,0x000877,0x000778,0x000879,0x00077b,0x00087b,0x00077d,0x00087e,
0x00087e,0x000880,0x000881,0x000882,0x000883,0x000885,0x000885,0x000986,0x000888,0x000988,0x00088a,0x00098b,0x00088c,
0x00098d,0x00088e,0x00098f,0x000990,0x000991,0x000992,0x000994,0x000994,0x000996,0x000997,0x000a97,0x000999,0x000a9a,
0x00099b,0x000a9c,0x00099e,0x000a9e,0x000a9f,0x000aa1,0x000aa1,0x000aa3,0x000aa4,0x000aa5,0x000aa6,0x000ba7,0x000aa8,
0x000ba9,0x000aab,0x000bab,0x000aad,0x000bae,0x000bae,0x000bb0,0x000bb0,0x000bb2,0x000bb3,0x000bb4,0x000bb5,0x000cb6,
0x000bb7,0x000cb8,0x000bba,0x000cba,0x000bbc,0x000cbd,0x000bbe,0x000cbf,0x000cc0,0x000cc1,0x000cc2,0x000cc4,0x000cc4,
0x000cc6,0x000cc7,0x000dc7,0x000cc9,0x000dca,0x000ccb,0x000dcc,0x000cce,0x000dce,0x000dcf,0x000dd1,0x000dd1,0x000dd3,
0x000dd3,0x000dd5,0x000dd6,0x000ed6,0x000dd8,0x000ed9,0x000dda,0x000edb,0x000ddd,0x000edd,0x000ede,0x000ee0,0x000ee0,
0x000ee2,0x000ee3,0x000ee4,0x000ee5,0x000fe6,0x000ee7,0x000fe8,0x000eea,0x000fea,0x000eec,0x000fed,0x000eee,0x000fef,
0x000ff0,0x0010ee,0x0011ec,0x0012ea,0x0013e7,0x0014e6,0x0015e3,0x0017e1,0x0017df,0x0019dc,0x0019db,0x001bd8,0x001cd6,
0x001dd4,0x001ed1,0x001fd0,0x0020cd,0x0022cb,0x0022c9,0x0024c7,0x0024c5,0x0026c2,0x0026c1,0x0028be,0x0029bc,0x002aba,
0x002bb7,0x002cb6,0x002db3,0x002fb1,0x002faf,0x0031ac,0x0031ab,0x0033a8,0x0034a6,0x0035a4,0x0036a2,0x0037a0,0x00389d,
0x00399c,0x003a99,0x003c97,0x003c95,0x003e92,0x003e91,0x00408e,0x00418c,0x00428a,0x004387,0x004486,0x004583,0x004781,
0x00477f,0x00497d,0x00497b,0x004b78,0x004b77,0x004d74,0x004e72,0x004f70,0x00506d,0x00516c,0x005269,0x005467,0x005465,
0x005662,0x005661,0x00585e,0x00595c,0x005a5a,0x005b58,0x005c56,0x005d53,0x005e52,0x005f4f,0x00614d,0x00614b,0x006348,
0x006347,0x006544,0x006642,0x006740,0x00683d,0x00693c,0x006a39,0x006c37,0x006c35,0x006e33,0x006e31,0x00702e,0x00702d,
0x00722a,0x007328,0x007426,0x007523,0x007622,0x00771f,0x00791d,0x00791b,0x007b18,0x007b17,0x007d14,0x007e12,0x007f10,
0x00800e,0x00810c,0x008209,0x008308,0x008405,0x008603,0x008601,0x0087fe,0x0087fd,0x0089fa,0x008af8,0x008bf6,0x008cf3,
0x008df2,0x008eef,0x0090ed,0x0090eb,0x0092e9,0x0092e7,0x0094e4,0x0094e3,0x0096e0,0x0097de,0x0098dc,0x0099d9,0x009ad8,
0x009bd5,0x009dd3,0x009dd1,0x009fcf,0x009fcd,0x00a1ca,0x00a2c8,0x00a3c6,0x00a4c4,0x00a5c2,0x00a6bf,0x00a7be,0x00a8bb,
0x00aab9,0x00aab7,0x00acb4,0x00acb3,0x00aeb0,0x00afae,0x00b0ac,0x00b1aa,0x00b2a8,0x00b3a5,0x00b5a3,0x00b5a1,0x00b79f,
0x00b79d,0x00b99a,0x00b999,0x00bb96,0x00bc94,0x00bd92,0x00be8f,0x00bf8e,0x00c08b,0x00c289,0x00c287,0x00c485,0x00c483,
0x00c680,0x00c77e,0x00c87c,0x00c97a,0x00ca78,0x00cb75,0x00cc74,0x00cd71,0x00cf6f,0x00cf6d,0x00d16a,0x00d169,0x00d366,
0x00d464,0x00d562,0x00d660,0x00d75e,0x00d85b,0x00da59,0x00da57,0x00dc55,0x00dc53,0x00de50,0x00de4f,0x00e04c,0x00e14a,
0x00e248,0x00e345,0x00e444,0x00e541,0x00e73f,0x00e73d,0x00e93b,0x00e939,0x00eb36,0x00ec34,0x00ed32,0x00ee30,0x00ef2e,
0x00f02b,0x00f12a,0x00f227,0x00f425,0x00f423,0x00f620,0x00f61f,0x00f81c,0x00f91a,0x00fa18,0x00fb16,0x00fc14,0x00fd11,
0x00fe10,0x01fe10,0x03fe10,0x03fd10,0x05fe10,0x05fd10,0x07fe10,0x08fd10,0x09fe10,0x0afd10,0x0bfd10,0x0cfd10,0x0efd10,
0x0efd10,0x10fd10,0x10fd10,0x12fd10,0x12fc10,0x14fd10,0x15fc10,0x16fd10,0x17fc10,0x18fd10,0x19fc10,0x1bfc10,0x1bfc10,
0x1dfc10,0x1dfc10,0x1ffc10,0x20fc10,0x21fc10,0x22fb10,0x23fc10,0x24fb10,0x25fc10,0x26fb10,0x28fc10,0x28fb10,0x2afc10,
0x2afb10,0x2cfb10,0x2dfb10,0x2efb10,0x2ffb10,0x30fb10,0x31fb10,0x33fb10,0x33fa10,0x35fb10,0x35fa10,0x37fb10,0x37fa10,
0x39fb10,0x3afa10,0x3bfa10,0x3cfa10,0x3dfa10,0x3efa10,0x40fa10,0x40fa10,0x42fa10,0x42f910,0x44fa10,0x45f910,0x46fa10,
0x47f910,0x48fa10,0x49f910,0x4af910,0x4bf910,0x4df910,0x4df910,0x4ff910,0x4ff910,0x51f910,0x52f910,0x53f910,0x54f810,
0x55f910,0x56f810,0x58f910,0x58f810,0x5af910,0x5af810,0x5cf810,0x5cf810,0x5ef810,0x5ff810,0x60f810,0x61f810,0x62f810,
0x63f710,0x65f810,0x65f710,0x67f810,0x67f710,0x69f810,0x6af710,0x6bf710,0x6cf710,0x6df710,0x6ef710,0x6ff710,0x70f710,
0x72f710,0x72f610,0x74f710,0x74f610,0x76f710,0x77f610,0x78f710,0x79f610,0x7af610,0x7bf610,0x7df610,0x7df610,0x7ff610,
0x7ff610,0x81f610,0x81f610,0x83f610,0x84f510,0x85f610,0x86f510,0x87f610,0x88f510,0x8af610,0x8af510,0x8cf510,0x8cf510,
0x8ef510,0x8ff510,0x90f510,0x91f510,0x92f510,0x93f410,0x94f510,0x95f410,0x97f510,0x97f410,0x99f510,0x99f410,0x9bf410,
0x9cf410,0x9df410,0x9ef410,0x9ff410,0xa0f410,0xa2f410,0xa2f310,0xa4f410,0xa4f310,0xa6f410,0xa6f310,0xa8f410,0xa9f310,
0xaaf310,0xabf310,0xacf310,0xadf310,0xaff310,0xaff310,0xb1f310,0xb1f310,0xb3f310,0xb4f210,0xb5f310,0xb6f210,0xb7f310,
0xb8f210,0xb9f310,0xbaf210,0xbcf210,0xbcf210,0xbef210,0xbef210,0xc0f210,0xc1f210,0xc2f210,0xc3f110,0xc4f210,0xc5f110,
0xc7f210,0xc7f110,0xc9f210,0xc9f110,0xcbf110,0xcbf110,0xcdf110,0xcef110,0xcff110,0xd0f110,0xd1f110,0xd2f010,0xd4f110,
0xd4f010,0xd6f110,0xd6f010,0xd8f110,0xd9f010,0xdaf110,0xdbf010,0xdcf010,0xddf010,0xdef010,0xdff010,0xe1f010,0xe1f010,
0xe3f010,0xe3ef10,0xe5f010,0xe6ef10,0xe7f010,0xe8ef10,0xe9f010,0xeaef10,0xecef10,0xecef10,0xeeef10,0xeeef10,0xf0ef10,
0xf0ee11,0xf0ef11,0xf0ee11,0xf0ee12,0xf0ed13,0xf1ed14,0xf0ec15,0xf1ec16,0xf0ec15,0xf1ec16,0xf0eb17,0xf1eb18,0xf0ea19,
0xf1ea19,0xf1ea19,0xf1ea1a,0xf1e91b,0xf1e91c,0xf1e81c,0xf1e81d,0xf1e81d,0xf2e81e,0xf1e71f,0xf2e71f,0xf1e620,0xf2e621,
0xf1e621,0xf2e622,0xf2e522,0xf2e523,0xf2e424,0xf2e425,0xf2e326,0xf2e426,0xf2e326,0xf3e327,0xf2e228,0xf3e229,0xf2e12a,
0xf3e229,0xf2e12a,0xf3e12b,0xf3e02c,0xf3e02d,0xf3df2d,0xf3e02d,0xf3df2e,0xf3df2f,0xf3de30,0xf4de30,0xf3dd31,0xf4de31,
0xf3dd32,0xf4dd33,0xf3dc34,0xf4dc34,0xf3db35,0xf4db36,0xf4db36,0xf4db37,0xf4da37,0xf4da38,0xf4d939,0xf4d93a,0xf4d93a,
0xf5d93a,0xf4d83b,0xf5d83c,0xf4d73d,0xf5d73e,0xf4d73d,0xf5d73e,0xf5d63f,0xf5d640,0xf5d541,0xf5d541,0xf5d541,0xf5d542,
0xf5d443,0xf6d444,0xf5d345,0xf6d345,0xf5d246,0xf6d346,0xf5d247,0xf6d248,0xf6d148,0xf6d149,0xf6d04a,0xf6d14a,0xf6d04b,
0xf6d04b,0xf6cf4c,0xf7cf4d,0xf6ce4e,0xf7cf4e,0xf6ce4e,0xf7ce4f,0xf6cd50,0xf7cd51,0xf6cc52,0xf7cd51,0xf7cc52,0xf7cc53,
0xf7cb54,0xf7cb55,0xf7ca56,0xf7ca56,0xf7ca56,0xf8ca57,0xf7c958,0xf8c959,0xf7c859,0xf8c85a,0xf7c85a,0xf8c85b,0xf8c75c,
0xf8c75c,0xf8c65d,0xf8c65e,0xf8c65e,0xf8c65f,0xf8c55f,0xf9c560,0xf8c461,0xf9c462,0xf8c462,0xf9c463,0xf8c363,0xf9c364,
0xf9c265,0xf9c266,0xf9c167,0xf9c266,0xf9c167,0xf9c168,0xf9c069,0xf9c06a,0xf9bf6a,0xfac06a,0xf9bf6b,0xfabf6c,0xf9be6d,
0xfabe6d,0xf9bd6e,0xfabe6e,0xfabd6f,0xfabd70,0xfabc70,0xfabc71,0xfabb72,0xfabc72,0xfabb73,0xfbbb74,0xfaba74,0xfbba75,
0xfab976,0xfbb977,0xfab977,0xfbb977,0xfbb878,0xfbb879,0xfbb77a,0xfbb77b,0xfbb77a,0xfbb77b,0xfbb67c,0xfcb67d,0xfbb57e,
0xfcb57e,0xfbb57e,0xfcb57f,0xfbb480,0xfcb481,0xfcb382,0xfcb382,0xfcb382,0xfcb383,0xfcb284,0xfcb285,0xfcb185,0xfcb186,
0xfcb087,0xfdb187,0xfcb088,0xfdb088,0xfcaf89,0xfdaf8a,0xfcae8b,0xfdaf8b,0xfdae8b,0xfdae8c,0xfdad8d,0xfdad8e,0xfdac8f,
0xfdad8e,0xfdac8f,0xfeac90,0xfdab91,0xfeab92,0xfdaa93,0xfeab92,0xfdaa93,0xfeaa94,0xfea995,0xfea996,0xfea896,0xfea897,
0xfea897,0xfea898,0xfea799,0xffa799,0xfea69a,0xffa69b,0xfea69b,0xffa69c,0xfea59c,0xffa59d,0xffa49e,0xffa49f,0xffa3a0,
0xffa3a0,0xffa2a0,0xffa2a0,0xffa0a1,0xffa0a2,0xff9fa2,0xff9fa2,0xff9ea2,0xff9da3,0xff9ca3,0xff9ca4,0xff9ba4,0xff9aa5,
0xff99a5,0xff99a5,0xff98a6,0xff97a7,0xff96a7,0xff96a7,0xff95a7,0xff94a9,0xff93a9,0xff93a9,0xff92a9,0xff91aa,0xff90ab,
0xff90ab,0xff8fab,0xff8eac,0xff8dac,0xff8dad,0xff8cad,0xff8bae,0xff8aae,0xff8aae,0xff89ae,0xff88b0,0xff87b0,0xff87b0,
0xff86b0,0xff85b1,0xff84b2,0xff84b2,0xff83b2,0xff82b3,0xff81b3,0xff81b4,0xff80b4,0xff7fb5,0xff7eb5,0xff7eb5,0xff7db6,
0xff7cb7,0xff7bb7,0xff7bb7,0xff7ab7,0xff79b8,0xff78b9,0xff78b9,0xff77b9,0xff76ba,0xff75ba,0xff75bb,0xff74bb,0xff73bc,
0xff72bc,0xff72bc,0xff71bd,0xff70be,0xff6fbe,0xff6fbe,0xff6ebe,0xff6dc0,0xff6cc0,0xff6cc0,0xff6bc0,0xff6ac1,0xff69c2,
0xff69c2,0xff68c2,0xff67c3,0xff66c3,0xff66c3,0xff65c4,0xff64c5,0xff63c5,0xff63c5,0xff62c5,0xff61c7,0xff60c7,0xff60c7,
0xff5fc7,0xff5ec8,0xff5dc9,0xff5dc9,0xff5cc9,0xff5bca,0xff5aca,0xff5acb,0xff59cb,0xff58cc,0xff57cc,0xff57cc,0xff56cd,
0xff55ce,0xff54ce,0xff54ce,0xff53ce,0xff52cf,0xff51d0,0xff51d0,0xff50d0,0xff4fd1,0xff4ed1,0xff4ed2,0xff4dd2,0xff4cd3,
0xff4bd3,0xff4bd3,0xff4ad4,0xff49d5,0xff48d5,0xff48d5,0xff47d5,0xff46d7,0xff45d7,0xff45d7,0xff44d7,0xff43d8,0xff42d8,
0xff42d9,0xff41d9,0xff40da,0xff3fda,0xff3fda,0xff3edb,0xff3edb,0xff3cdc,0xff3cdc,0xff3bdc,0xff3bdd,0xff39de,0xff39de,
0xff38de,0xff38de,0xff36e0,0xff36e0,0xff35e0,0xff35e0,0xff33e1,0xff33e2,0xff32e2,0xff32e2,0xff30e3,0xff30e3,0xff2fe3,
0xff2fe4,0xff2de5,0xff2de5,0xff2ce5,0xff2ce5,0xff2ae7,0xff2ae7,0xff29e7,0xff29e7,0xff27e8};
#endif

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS,  TFT_DC, TFT_RST);

Adafruit_AMG88xx amg;
unsigned long delayTime;

float pixels[AMG88xx_PIXEL_ARRAY_SIZE];
uint16_t subpixelbuffer[16];//this is a buffer that holds pixel info to update several pixesl at a time!

//dont change optimize here, look for value at top
#if optimize > 0 & colorMode <2

int pixelsbuf[AMG88xx_PIXEL_ARRAY_SIZE];

#endif

#if optimize > 0 & colorMode > 1
//we just doulbe buffer size to words instead of 256 level bytes because of more color data at least 1024 colors now, maybe more in future
int pixelsbuf[AMG88xx_PIXEL_ARRAY_SIZE];//we double size of array so it can handle larger numbers for larger color tables

#endif

#if interpolatemode >1 
int postbuffer[AMG88xx_PIXEL_ARRAY_SIZE*4];//this is a temp buffer it wont always be needed
byte color4buf;//we use for drawing 4 at a time if enabled, just counts 0 to 3, or 0-15
#endif

#if interpolatemode >2 
uint16_t subpixelbuffer2[64];//this is a buffer that holds pixel info to update up to 64  pixesl at a time!
int postbuffer2[AMG88xx_PIXEL_ARRAY_SIZE*16];//this is a temp buffer it wont always be needed
byte color4buf2;//we use for drawing several pixels at a time
#endif


//uint16_t displayPixelWidth, displayPixelHeight;
void subpixelagain(){//this loop is temporary
 

}

void setup() {
 // Serial.begin(9600);
 Serial.begin(115200);
    Serial.println(F("AMG88xx thermal camera!"));

    tft.initR(INITR_144GREENTAB);   // initialize a ST7735S chip, black tab
    tft.fillScreen(ST7735_BLACK);

#define    displayPixelWidth  tft.width() /8  //allows values to be hardcoded
#define    displayPixelHeight   tft.height() / 8

    //tft.setRotation(3);

    bool status;
    
    // default settings
    status = amg.begin();
    if (!status) {
        Serial.println(F("Could not find a valid AMG88xx sensor, check wiring!"));
        while (1);
    }
    
    Serial.println( F("-- Thermal Camera Test --"));
   
    delay(100); // let sensor boot up

}


// friends it may be magical bologna, but it speeds things up quite abit!
//it looks at buffered value, and only updates the greated changes pixel locations
//and once changed, the next sets of pixels get updated. this reduces noise and 
//increases data thruput to display by only updating if change, and if overloaded 
//by most change. faster performance if fewer pixels set to priority                          
//      data range  -->     ||  limit data  ||Fuzzy logic data reduction                                           
//=========================]|| to greatest  ||==========================
//   bandwith compressor    ||    changed   || (by james villeneuve 2018)
#define speedUpCompression 8 //lower number is faster (it sets priority pixels amount, however too much means rest of display updates more slowly)
// also includes code to make sure every pixel updates but at a slower rate 1/8 or 1/16 think of it like a keyframe that updates 1/16 of display at a time no matter what  setting is

//higher number precision means more change allowed for pixel noise

//noise suppression, what shows at lower limits goes to lowest color 
int compressionnumber;//this counts pixels processed, if to many processed we make compression flux higher
int compressionflux=50;//this number goes up and down depending on how many pixesl are changing (usually from noise)

void subpixelcolor(int Pixelsample,int SidePixel,int BottomPixel,int BottomSidePixel,byte Xdir, byte Ydir,byte x, byte y){
//this routine figures out how to sub sample pixel, and returns pixel in x,y position from sub
//not yet in this place but soon i hope
 
  
}

//********** faster than map data, since we know we are using 256/ or 1024 values and start with min of 0
float cachedTempVar;//we use for comparing, keep same range unless it changes again
float cachedtempdata;//this is data we reuse!!
float Fasttempcachemap256(float valuechange){
//int colorIndex= (pixels[i+j*8]-MINTEMP)*1024/(MAXTEMP-MINTEMP);//this should do the same thing!
if (cachedTempVar !=MAXTEMP+MINTEMP){cachedtempdata=256/(MAXTEMP-MINTEMP);cachedTempVar =MAXTEMP+MINTEMP;}
valuechange=(valuechange-MINTEMP)*cachedTempVar;
return valuechange;
}


float Fasttempcachemap1024(float valuechange){
//int colorIndex= (pixels[i+j*8]-MINTEMP)*1024/(MAXTEMP-MINTEMP);//this should do the same thing!
if (cachedTempVar !=MAXTEMP+MINTEMP){cachedtempdata=1024/(MAXTEMP-MINTEMP);cachedTempVar =MAXTEMP+MINTEMP;}
valuechange=(valuechange-MINTEMP)*cachedTempVar;
return valuechange;
}


//****************** end of faster mapping
int colorRangeSet(int colordata, float Value){
//we determine range of color for temp
#if colorMode <2 
  colordata= Fasttempcachemap256(Value);
 #else
 colordata=Fasttempcachemap1024( Value);//we constrain color after subsampling
 
#endif
return colordata;
}
int colorClamp(int colordata){
#if colorMode < 2
 colordata= colordata &255;//subsample with real pixel and surounding pixels
#else
 colordata= colordata&1023;//subsample with real pixel and surounding pixels
#endif
if (colordata<0){ colordata=0;}
return colordata;

}
//this area is code that updates display with numeric data and shows color bar if set
void displayaddons(){
#if showcolorbar == true
//we erase areas where text shows on side first

//we only draw bar if advanded st77xx drivers included!
//upper limit temp
#if temp_Fahrenheit == true
byte tempf=MAXTEMP*1.8+32;
byte charplace1a= tempf /10;//we have upper limit
byte charplace2a= tempf-charplace1a*10;//we have upper limit
#endif

#if temp_Fahrenheit == false
byte tempf=MAXTEMP;
byte charplace1a= tempf /10;//we have upper limit
byte charplace2a= tempf-charplace1a*10;//we have upper limit
#endif
if (tempf<100){
tft.drawChar(128-22,128-13,48+charplace1a,0xFFFF,0x0000,2);//already in code if same color, transperant background!
tft.drawChar(128-11,128-13,48+charplace2a,0xFFFF,0x0000,2);//already in code if same color, transperant background!
}else{
//draw NA
tft.drawChar(128-11,128-13,65,0xFFFF,0x0000,2);//already in code if same color, transperant background!
tft.drawChar(128-22,128-13,78,0xFFFF,0x0000,2);//already in code if same color, transperant background!
}


//tft.drawChar(11,128-13,65,0xFFFF,0xFFFF,2);//already in code if same color, transperant background!
//tft.drawChar(0,128-13,78,0xFFFF,0xFFFF,2);//already in code if same color, transperant background!

//lower limit temp
#if temp_Fahrenheit == true
byte tempf2=MINTEMP*1.8+32;
byte charplace1b= tempf2 /10;//we have upper limit
byte charplace2b= tempf2-charplace1b*10;//we have upper limit
#endif

#if temp_Fahrenheit == false
byte tempf2=MINTEMP;
byte charplace1b= tempf2 /10;//we have upper limit
byte charplace2b= tempf2-charplace1b*10;//we have upper limit
#endif
if (tempf2>0){
tft.drawChar(0,128-13,48+charplace1b,0xFFFF,0x0000,2);//already in code if same color, transperant background!
tft.drawChar(11,128-13,48+charplace2b,0xFFFF,0x0000,2);//already in code if same color, transperant background!
}else{
//draw NA
tft.drawChar(11,128-13,65,0xFFFF,0x0000,2);//already in code if same color, transperant background!
tft.drawChar(0,128-13,78,0xFFFF,0x0000F,2);//already in code if same color, transperant background!
}
// we draw  color bar!

//this area for keymap at bottom of display
tft.drawRect(24,  128-13,80,  10,0x0000) ;//box outline
float range=MAXTEMP-MINTEMP;
float stepcolorchange=range*0.025;//1/40
float colorstepping=MINTEMP;//this is the start value
int colorOfbararea=0;
for (int drawbar=0;drawbar<40;drawbar++){
colorOfbararea=colorRangeSet(colorOfbararea,colorstepping);
  tft.fillRect(24+drawbar*2, 128-12,2, 8,(uint16_t)pgm_read_word_near(camColors+colorOfbararea));
colorstepping+= stepcolorchange; 
}

#endif
//this is last area before refresh most the code here and below is just for temp readout, averaging middle 4 data.
#if show_temp_readout == true 

#if temp_Fahrenheit == true
//we convert to Fahrenheit!
int temperature= pixels[8*4+4]*1.8+32;//+pixels[8*4+5]*1.8+32+pixels[8*3+4]*1.8+32+pixels[8*3+5]*1.8+32)/4;// we sample 4 samples because center of screen is 4 samples
#else
int temperature= (pixels[8*4+4]+pixels[8*4+5]+pixels[8*3+4]+pixels[8*3+5])/4;// we sample 4 samples because center of screen is 4 samples
#endif



//Serial.println(temperature);// for testing
//we read from float buffer and convert to int, then convert to string output this method is ugly, just no reason to invest in better method.
if (temperature >0 & temperature<100){
byte charplace1=temperature/10;//we have upper limit
byte charplace2=temperature-charplace1*10;//we have upper limit

tft.drawChar(64-11,64+5,48+charplace1,0xFFFF,0xFFFF,2);//already in code if same color, transperant background!
tft.drawChar(64-10+11,64+5,48+charplace2,0xFFFF,0xFFFF,2);//already in code if same color, transperant background!

}else{
if (temperature>99){//we put 'NA' on screen
tft.drawChar(64-11,64+5,78,0xFFFF,0xFFFF,2);//already in code if same color, transperant background!
tft.drawChar(64-10+11,64+5,65,0xFFFF,0xFFFF,2);//already in code if same color, transperant background!
}
}
//we print a little 'o' faster than drawing a circle.
tft.drawChar(60,60,111,0xFFFF,0xFFFF,1);//already in code if same color, transperant background!

#endif

}
//********* end of area*****************************************
byte slowupdate=0;//used to refesh different amounts, makes sure pixels update more timely. solves noisy pixels
long timer=micros();//for timing
void loop() {
//this line below reads the sensor data

amg.readPixels(pixels);
#if autorange == true

float templow=1024;
float temphi=0;
for (int counti=0;counti<63; counti ++){
//some sort of crude bubble sort.
if (pixels[counti]>temphi){temphi=pixels[counti];}
if (pixels[counti]<templow){templow=pixels[counti];}
};
MINTEMP=MINTEMP*0.5+(templow-2)*0.5;
MAXTEMP=MAXTEMP*0.5+(temphi+1)*0.5;
#endif
//*********
float tempr=0.0;

 byte i=0;
 int j=0; 
 byte k=0;
//long timer =micros();
compressionnumber=0;// we reset each time thru
 slowupdate++;slowupdate=slowupdate&15; //we run this routing to update a few times0,1, maybe more later on
 //delay(100);
 while(k<8 ){ 
switch(k){// this allows j to do interleaving of page, when updates are slower, and improvese results of compressed bandwitdh
case 0: j=0; break;case 1: j=2; break;case 2: j=4; break;case 3: j=6; break;case 4: j=1; break;case 5: j=3; break;case 6: j=5; break;case 7: j=7; break;
          }
if (i>7){i=0;k++;}//here we run code that makes sense of supersubsamples, sample is done when i=8,k=16
// |
// |
// V i . j ------>direction of display sensor. helps when figuring out interpolation

timer=micros();//used for testing


    int colorIndex  =  colorRangeSet( colorIndex , pixels[i+j*8]);


    //we now compress and only update pixels on screen that change the most! it works and over time they all change, but to be sure force updates
#if optimize>1 

#if noisefilter > 0 & optimize == 2 //optimise needs to be set to 2 for noise filter to be active
   //if noise filter value needs to change by a set amount
  
  if (pixelsbuf[i+j*8] -colorIndex >noisefilter || colorIndex-pixelsbuf[i+j*8]>noisefilter){

   if  ((pixelsbuf[i+j*8] -colorIndex)>compressionflux ||(colorIndex-pixelsbuf[i+j*8]>compressionflux ||i+j*8==(i+j*8)|slowupdate )){

#endif

#if noisefilter == 0
    if  ((pixelsbuf[i+j*8] -colorIndex)>compressionflux ||(colorIndex-pixelsbuf[i+j*8]>compressionflux ||i+j*8==(i+j*8)|slowupdate )){//loop with no noise filter code
#endif
    
    //slowupdate value just esuresallows non priority pixel areas to update as well besides noise
    //we only draw if it is pixle with higher priority of change AND PIXEL IS NOT SAME COLOR ALREADY
#endif    
 
//below checks the buffer 
#if optimize >0 

if (colorIndex !=pixelsbuf[i+j*8]){
//we update each pixel data
pixelsbuf[i+j*8] =colorIndex;//we just make sure latest pixel value gets stored here

#endif
#if optimize >1   
if (i+j*8 !=(i+j*8)|slowupdate)    compressionnumber++;// we only count priority pixels, not ones with slower refresh
 
#endif    
#if  showcolorbar == true 
if ( i < 7 ){ //we dont write last line of data   
#endif

#if interpolatemode == 0
   //this is original for display code pixel placement
   //there is also spi optimizations to allow spi bursts during pixel writes if using included st77xx.h and st77xx.cpp files 
colorIndex=colorClamp(colorIndex);


   #if  subpixelcoloroptimized !=-1 //we test without lcd writes with -1
    tft.fillRect(displayPixelWidth *j, displayPixelHeight * i,displayPixelWidth, displayPixelHeight,(uint16_t)pgm_read_word_near(camColors+colorIndex));
    #endif
#endif



/////////////////////////////////begin of loop unroll///////////////////////////////////// 
#if interpolatemode > 0
//long timer =micros();//we are timing code for speed
//how it updates when more than 2x2 sub pixels
int  pixelSizeDivide =2; //*interpolatemode; //we may not need to multiply at this point. leaving here for future revisions
//[0][4][8][c] or [0][2] //order reverses depending on sample interpolateSampleDir 
//[1][5][9][d]    [1][3]
//[2][6][a][e]
//[3][7][b][f]
  //fast subdivide low memory pixel enhancing code (by James Villeneuve 7-2018 also referencing MIT code and adafruit library for pixel placement code)
     
int interpolatesampledir2=1; if(i<4){interpolatesampledir2=1;}else{interpolatesampledir2=-1;}//top(1) or bottom quadrunt (-1)
int interpolateSampleDir =1;// left  (1) or right quadrunt (-1)
int offset=0;

//getsubpixelcolor()//side pixel,vertical pixil,LeftOrRigh,current pixel
if (j<4){interpolateSampleDir =1;}// we process left to right here . we need to change this so it scales with display resolution
         else{interpolateSampleDir =-1;offset=displayPixelHeight-displayPixelHeight/pixelSizeDivide;}//if past half way on display we sample in other direction
 //long timecount=micros();
// getsubpixelcolor(pixelSizerDivide);//side pixel,vertical pixil,LeftOrRigh,current pixel
int raster_x=0;
while (raster_x !=(pixelSizeDivide*interpolateSampleDir)){ //done with != instead of <> so i could invert direction ;)  
    int raster_y=0;
    while (raster_y != pixelSizeDivide* interpolateSampleDir) { //0,1  

//we keep sample size from nieghbor pixels even when sample divides increase

#if colorMode <2 //Fasttempcachemap256(pixels[i+j*8]);
int  tempcolor= Fasttempcachemap256(pixels[(i+raster_y+interpolatesampledir2)+(j+raster_x)*8]);
 #else
int  tempcolor=Fasttempcachemap1024(pixels[(i+raster_y+interpolatesampledir2)+(j+raster_x)*8]);//we constrain color after subsampling
 
#endif

//next line changes the average of the color between the main pixel and the sub pixels
tempcolor=(( tempcolor*(2-raster_y)+ colorIndex*raster_y)+tempcolor*(raster_x)+colorIndex*(2-raster_x))/4;//subsample with real pixel and surounding pixels


#if colorMode < 2
tempcolor=tempcolor &255;//subsample with real pixel and surounding pixels
#else
tempcolor=tempcolor&1023;//subsample with real pixel and surounding pixels
#endif
#endif  //interpolatemode
//int  tempcolor= map(pixels[(i+(raster_y/(pixelSizeDivide/2))+interpolatesampledir2)+(j+(raster_x/(pixelSizeDivide/2)))*8], MINTEMP, MAXTEMP, 0, 1023);//we constrain color after subsampling
#if colorMode <2
////int  tempcolor= pixels[(i+(raster_y)+interpolatesampledir2)+(j+(raster_x)*8];//we constrain color after subsampling
 #else
//int  tempcolor= map(pixels[(i+(raster_y+interpolatesampledir2)+(j+(raster_x/(pixelSizeDivide/2)))*8], MINTEMP, MAXTEMP, 0, 1023);//we constrain color after subsampling
 
#endif
//***************************************************************************************************************************************************************
//this is end of draw area for sub pixels 32 x32 resolution

#if interpolatemode > 1
//we take data from subpixel routine, and run it to a buffer temporarily. this buffer is 16x16, then we run another subsample. seems repetative, but is needed to visualize how to iterate sub sampling
#define displayPixelHeightx 2
#define displayPixelWidthx 2
#define offsetx 1
//this stores 8x8 sub sample data into a buffer of 16x16********************************************************************************************************
int tempc=0;if (j<4){tempc=-1;}//corrects an error that i have not fixe another way //postbuffer2
postbuffer[((j+j+offsetx+ (interpolateSampleDir)*(raster_x*interpolateSampleDir))+tempc)*16+i+ i+1+(interpolateSampleDir)*(raster_y*interpolateSampleDir)+tempc]=tempcolor;
#endif

#if  interpolatemode == 1
//we use data directly from interpolated sub
   #if  subpixelcoloroptimized !=-1 //we test without lcd writes with -1
fillRectFast(displayPixelWidth *j+
offset+ (interpolateSampleDir*displayPixelWidth/pixelSizeDivide)*(raster_x*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
displayPixelHeight* i+offset+(interpolateSampleDir*displayPixelHeight/pixelSizeDivide)*(raster_y*interpolateSampleDir),
displayPixelWidth/pixelSizeDivide,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
displayPixelHeight/pixelSizeDivide,//we divide hieght of pixels.
(uint16_t)pgm_read_word_near(camColors+tempcolor));  //we update pixel location with new subsampled pixel.
#endif
#endif

//would it make sense to subdivide to color of pixel directly? yes except camcolors is set with colors translated for heat.

//delay(50);
#if interpolatemode >0
raster_y +=  interpolateSampleDir;
   }//interpolatepixel_y 

   raster_x += interpolateSampleDir;
}//interpolatepixel_x 
#endif
 /////////////////////////////////end of loop unroll/////////////////////////////////////
#if  interpolatemode >1
uint16_t jxx=j+j;
while (jxx != j+j+2){//double resolution in j
 uint16_t ixx=i+i;

while (ixx != i+i+2){//double resolution in i
//Serial.println(jxx);//for testing

int colorIndexx = postbuffer[ixx+jxx*16];//taking from 16x16 buffer

int offsetxx=0;
#define pixelSizeDividex 2

int raster_xx=0;
while (raster_xx !=(interpolateSampleDir+interpolateSampleDir)){ //done with != instead of <> so i could invert direction ;)  
    int raster_yx=0;
    while (raster_yx !=interpolateSampleDir+interpolateSampleDir) { //0,1  
#endif
//we keep sample size from nieghbor pixels even when sample divides increase
#if interpolatemode > 1
//no need to color map for this as it is already an int value
int  tempcolorx= postbuffer[(ixx+raster_yx+interpolatesampledir2)+(jxx+raster_xx)*16];//we constrain color after subsampling

#endif


#if  interpolatemode  > 1
//next line changes the average of the color between the main pixel and the sub pixels
tempcolorx=(( tempcolorx*(2-raster_yx)+ colorIndexx*raster_yx)+(tempcolorx*(raster_xx)+colorIndexx*(2-raster_xx)))/4;//subsample with real pixel and surounding pixels
//#endif



tempcolorx=colorClamp(tempcolorx);//subsample with real pixel and surounding pixels
//this is where 32 x32 is buffered so it can be upsampled

#if interpolatemode > 2 //this stores 32 x32 buffer, and we upsample it to 64x64. we will remove need of this at a later date.
//we take data from subpixel routine, and run it to a buffer temporarily. this buffer is 16x16, then we run another subsample. seems repetative, but is needed to visualize how to iterate sub sampling


 
#define offsetxxx 1
//this stores 16x16 sub sample data into a buffer of 32x32********************************************************************************************************
int tempcx=0;if (jxx<8){tempcx=-1;}//corrects an error that i have not fixe another way . this same fix works for bigger buffer
//we now have data stored in second buffer, seems to be correct.
postbuffer2[((jxx+jxx+offsetxxx+ (interpolateSampleDir)*(raster_xx*interpolateSampleDir))+tempcx)*32+ixx+ixx+1+(interpolateSampleDir)*(raster_yx*interpolateSampleDir)+tempcx]=tempcolorx;
#endif




#if interpolatemode == 2 //we run this only if it is set to 2, other method needed for 3 or more
#if subpixelcoloroptimized ==1 //this is for writing 4 rectangles at a time!
subpixelbuffer[color4buf]=(uint16_t)pgm_read_word_near(camColors+tempcolorx);
color4buf++;//we count 0-3 and reset again, each pixel set and we draw 4 colors at a time
if (color4buf>3){color4buf=0;//we leave this open because each reset of numbers triggers a display write!
int tempint=interpolateSampleDir*4;//we reuse so calculate one time
if (jxx<8){offsetxx=-4;}else{offsetxx=4;}//this is different on 4 writes at once because rectangle call is bigger
#endif




#if subpixelcoloroptimized == 2 //this is for writing 4 rectangles at a time!
subpixelbuffer[color4buf]=(uint16_t)pgm_read_word_near(camColors+tempcolorx);
color4buf++;//we count 0-3 and reset again, each pixel set and we draw 4 colors at a time
if (color4buf>15){color4buf=0;//we leave this open because each reset trigger display write
int tempint=interpolateSampleDir*4;//we reuse so calculate one time
if (jxx<8){offsetxx=-12;}else{offsetxx=-4;}//this is different on 16 writes becauae pixels are offset more.
#endif

#if subpixelcoloroptimized == 0  //this means we write every single time to display

int tempint=interpolateSampleDir*4;//we reuse so calculate one time
if (jxx>7){offsetxx=4;}//this line needed to fix the offsets value for some reason.
   #if  subpixelcoloroptimized !=-1 //we test without lcd writes with -1
fillRectFast(jxx*8+
offsetxx+ tempint*(raster_xx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ixx*8+offsetxx+tempint*(raster_yx*interpolateSampleDir),
4,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
4,//we divide hieght of pixels.
(uint16_t)pgm_read_word_near(camColors+tempcolorx));  //we update pixel location with new subsampled pixel.
#endif
#endif
#if subpixelcoloroptimized == 1 //we finish write update to display
//this write only happens every 4 loops to display! we capture 4 pixels and update all at one time!
if (jxx<8){
tft.fillRectFast4colors(jxx*8+
offsetxx+ tempint*(raster_xx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ixx*8+offsetxx+tempint*(raster_yx*interpolateSampleDir),
8,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
8,//we divide hieght of pixels.
subpixelbuffer[0],//we write pixels in different order so to match 4 rect writes at once
subpixelbuffer[2],// [0][2]<-write    [0][1] <-4 at a time square updates first half of screen
subpixelbuffer[1],// [1][3]           [2][3] this is why ordering is different
subpixelbuffer[3]);
}else{
tft.fillRectFast4colors(jxx*8+
offsetxx+ tempint*(raster_xx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ixx*8+offsetxx+tempint*(raster_yx*interpolateSampleDir),
8,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
8,//we divide hieght of pixels.
subpixelbuffer[3],//we write pixels in different order so to match 4 rect writes at once
subpixelbuffer[1],// [3][1]<-write    [0][1] <-4 at a time square updates second half of screen
subpixelbuffer[2],// [2][0]           [2][3] this is why ordering is different
subpixelbuffer[0]);//order different on other side of display
  
}
}//we close loop for reset of buffer after write 4 pixels at once done!
#endif  ///



#if subpixelcoloroptimized == 2 //we finish write update to display

//we write 16 squarea at a time to display. this reduces command calls drastically
//this write only happens every 16 loops to display! we capture 16 pixels and update all at one time!
if (jxx<8){
tft.fillRectFast16colors(jxx*8+
offsetxx+ tempint*(raster_xx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ixx*8+offsetxx+tempint*(raster_yx*interpolateSampleDir),
16,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
16,//we divide hieght of pixels.
subpixelbuffer[0  ],//we write pixels in different order so to match 4 rect writes at once
subpixelbuffer[2  ],//  [0][2]|[0][2]<-write    [0][1][2][3] <-4 at a time square updates first half of screen
subpixelbuffer[0+8],// 0[1][3]|[1][3] 8         [4][5][6][7] this is why ordering is different
subpixelbuffer[2+8],//----------------          [8][9][A][B] //this is how command updates screen
subpixelbuffer[1  ],//  [0][2]|[0][2]           [C][D][E][F] ->zoom out [0.. ][4.. ]//how buffer is put  
subpixelbuffer[3  ],// 4[1][3]|[1][3] 12                //              [8.. ][12..]//into 16 at a time command
subpixelbuffer[1+8],                     
subpixelbuffer[3+8],// yes i know how to add it just makes more sense to show how
subpixelbuffer[0+4],// it works and let compiler combine numbers
subpixelbuffer[2+4],
subpixelbuffer[0+12],
subpixelbuffer[2+12],
subpixelbuffer[1+4],
subpixelbuffer[3+4],
subpixelbuffer[1+12],
subpixelbuffer[3+12]);

}else{
tft.fillRectFast16colors(jxx*8+
offsetxx+ tempint*(raster_xx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ixx*8+offsetxx+tempint*(raster_yx*interpolateSampleDir),
16,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
16,//we divide hieght of pixels.
subpixelbuffer[3  ],//we write|pixels in different order so to match 4 rect writes at once
subpixelbuffer[1  ],//  [3][1]|[3][1]<-write    [0][1][2][3] <-4 at a time square updates first half of screen
subpixelbuffer[3+8],//0 [2][0]|[2][0] 8         [4][5][6][7] this is why ordering is different
subpixelbuffer[1+8],// -----------------        [8][9][A][B] //this is how command updates screen
subpixelbuffer[2  ],//  [3][1]|[3][1]           [C][D][E][F] ->zoom out [0.. ][4.. ]//how buffer is put
subpixelbuffer[0  ],//4 [2][0]|[2][0] 12                    //          [8.. ][12..]//into 16 at a time command     
subpixelbuffer[2+8],//        |          
subpixelbuffer[0+8],// yes i know how to add it just makes more sense to show how
subpixelbuffer[3+4],// it works and let compiler combine numbers
subpixelbuffer[1+4],
subpixelbuffer[3+12],
subpixelbuffer[1+12],
subpixelbuffer[2+4],
subpixelbuffer[0+4],
subpixelbuffer[2+12],
subpixelbuffer[0+12]);  
}





}//we close loop for reset of buffer after write 4 pixels at once done!
#endif //subpixelcoloroptimized == 2

#endif //interpolate == 2
raster_yx +=  interpolateSampleDir;
   }//interpolatepixel_y 

   raster_xx += interpolateSampleDir;
}//interpolatepixel_x  



// ***************** here is where 32x32 data is upscaled to 64x64 data, 32x32 means that pixels are 4x4, 64*64 means that pixels are 8x8 and made into rectanges
#if  interpolatemode >2
uint16_t jx32=jxx+jxx;
while (jx32 != jxx+jxx+2){//double resolution in j
 uint16_t ix32=ixx+ixx;

while (ix32 != ixx+ixx+2){//double resolution in i
//Serial.println(jx32);//for testing

int colorIndex32 = postbuffer2[ix32+jx32*32];

int offsetx32=4;
#define pixelSizeDividexx 4

int raster_xxx=0;
while (raster_xxx !=(interpolateSampleDir+interpolateSampleDir)){ //done with != instead of <> so i could invert direction ;)  
    int raster_yxx=0;
    while (raster_yxx !=interpolateSampleDir+interpolateSampleDir) { //0,1  

//we keep sample size from neighbor pixels even when sample divides increase

//#if interpolatemode > 2
//no need to color map for this as it is already an int value
int  tempcolorx32= postbuffer2[(ix32+raster_yxx+interpolatesampledir2)+(jx32+raster_xxx)*32];//we constrain color after subsampling




//#if  interpolatemode  > 1
//next line changes the average of the color between the main pixel and the sub pixels
tempcolorx32=(( tempcolorx32*(2-raster_yxx)+ colorIndex32*raster_yxx)+(tempcolorx32*(raster_xxx)+colorIndex32*(2-raster_xxx)))/4;//subsample with real pixel and surounding pixels



#if colorMode < 2
tempcolorx32=tempcolorx32&255;//subsample with real pixel and surounding pixels
#else
tempcolorx32=tempcolorx32&1023;//subsample with real pixel and surounding pixels
#endif
#if subpixelcoloroptimized == 3 //this is for writing 64 rectangles at a time!
subpixelbuffer2[color4buf2]=(uint16_t)pgm_read_word_near(camColors+tempcolorx32);
color4buf2++;//we count 0-3 and reset again, each pixel set and we draw 4 colors at a time
if (color4buf2>63){color4buf2=0;//we leave this open because each reset trigger display write
int tempintx=interpolateSampleDir*4;//we reuse so calculate one time
if (jx32<16){offsetx32=-16;}else{offsetx32=-8;}//this is different on 64 writes becauae pixels are offset more.
#endif

#if subpixelcoloroptimized == 2 //this is for writing 16 rectangles at a time!
subpixelbuffer2[color4buf2]=(uint16_t)pgm_read_word_near(camColors+tempcolorx32);
color4buf2++;//we count 0-3 and reset again, each pixel set and we draw 4 colors at a time
if (color4buf2>15){color4buf2=0;//we leave this open because each reset trigger display write
int tempintx=interpolateSampleDir*4;//we reuse so calculate one time
if (jx32<16){offsetx32=-8;}else{offsetx32=0;}//this is different on 16 writes becauae pixels are offset more.
#endif



#if subpixelcoloroptimized == 0 //one pixel at a time
//this is write one pixel at a time 64 x64 mode
int tempintx=interpolateSampleDir*2;//we reuse so calculate one time
//if (jx32>15){offsetx32=4;}//this line needed to fix the offsets value for some reason.
#if  subpixelcoloroptimized !=-1 //we test without lcd writes with -1
fillRectFast(jx32*4+ offsetx32+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetx32+tempintx*(raster_yxx*interpolateSampleDir),
2,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
2,//we divide hieght of pixels.
(uint16_t)pgm_read_word_near(camColors+tempcolorx32));  //we update pixel location with new subsampled pixel.
#endif
#endif

//64 bit one rectangle at a time output
#if subpixelcoloroptimized ==1 //this is for writing 4 rectangles at a time!
subpixelbuffer2[color4buf2]=(uint16_t)pgm_read_word_near(camColors+tempcolorx32);
color4buf2++;//we count 0-3 and reset again, each pixel set and we draw 4 colors at a time
if (color4buf2>3){color4buf2=0;//we leave this open because each reset of numbers triggers a display write!
int tempintx=interpolateSampleDir*2;//we reuse so calculate one time
if (jx32<16){offsetx32=-4;}else{offsetx32=4;}//this is different on 4 writes at once because rectangle call is bigger
#endif




#if subpixelcoloroptimized == 1 //we finish write update to display
//this write only happens every 4 loops to display! we capture 4 pixels and update all at one time!
if (jx32<16){
tft.fillRectFast4colors(jx32*4+
offsetxx+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetx32+tempintx*(raster_yxx*interpolateSampleDir),
4,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
4,//we divide hieght of pixels.
subpixelbuffer2[0],//we write pixels in different order so to match 4 rect writes at once
subpixelbuffer2[2],// [0][2]<-write    [0][1] <-4 at a time square updates first half of screen
subpixelbuffer2[1],// [1][3]           [2][3] this is why ordering is different
subpixelbuffer2[3]);
}else{
tft.fillRectFast4colors(jx32*4+
offsetx32+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetxx+tempintx*(raster_yxx*interpolateSampleDir),
4,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
4,//we divide hieght of pixels.
subpixelbuffer2[3],//we write pixels in different order so to match 4 rect writes at once
subpixelbuffer2[1],// [3][1]<-write    [0][1] <-4 at a time square updates second half of screen
subpixelbuffer2[2],// [2][0]           [2][3] this is why ordering is different
subpixelbuffer2[0]);//order different on other side of display
  
}//else
}//if color4buf2>3
#endif
#if subpixelcoloroptimized == 2 //we finish write update to display

//we write 16 squarea at a time to display. this reduces command calls drastically
//this write only happens every 16 loops to display! we capture 16 pixels and update all at one time!
if (jxx<8){
tft.fillRectFast16colors(jx32*4+
offsetx32+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetx32+tempintx*(raster_yxx*interpolateSampleDir),
8,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
8,//we divide hieght of pixels.
subpixelbuffer2[0  ],//we write pixels in different order so to match 4 rect writes at once
subpixelbuffer2[2  ],//  [0][2]|[0][2]<-write    [0][1][2][3] <-4 at a time square updates first half of screen
subpixelbuffer2[0+8],// 0[1][3]|[1][3] 8         [4][5][6][7] this is why ordering is different
subpixelbuffer2[2+8],//----------------          [8][9][A][B] //this is how command updates screen
subpixelbuffer2[1  ],//  [0][2]|[0][2]           [C][D][E][F] ->zoom out [0.. ][4.. ]//how buffer is put  
subpixelbuffer2[3  ],// 4[1][3]|[1][3] 12                //              [8.. ][12..]//into 16 at a time command
subpixelbuffer2[1+8],                     
subpixelbuffer2[3+8],// yes i know how to add it just makes more sense to show how
subpixelbuffer2[0+4],// it works and let compiler combine numbers
subpixelbuffer2[2+4],
subpixelbuffer2[0+12],
subpixelbuffer2[2+12],
subpixelbuffer2[1+4],
subpixelbuffer2[3+4],
subpixelbuffer2[1+12],
subpixelbuffer2[3+12]);

}else{
tft.fillRectFast16colors(jx32*4+
offsetx32+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetx32+tempintx*(raster_yxx*interpolateSampleDir),
8,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
8,//we divide hieght of pixels.
subpixelbuffer2[3  ],//we write|pixels in different order so to match 4 rect writes at once
subpixelbuffer2[1  ],//  [3][1]|[3][1]<-write    [0][1][2][3] <-4 at a time square updates first half of screen
subpixelbuffer2[3+8],//0 [2][0]|[2][0] 8         [4][5][6][7] this is why ordering is different
subpixelbuffer2[1+8],// -----------------        [8][9][A][B] //this is how command updates screen
subpixelbuffer2[2  ],//  [3][1]|[3][1]           [C][D][E][F] ->zoom out [0.. ][4.. ]//how buffer is put
subpixelbuffer2[0  ],//4 [2][0]|[2][0] 12                    //          [8.. ][12..]//into 16 at a time command     
subpixelbuffer2[2+8],//        |          
subpixelbuffer2[0+8],// yes i know how to add it just makes more sense to show how
subpixelbuffer2[3+4],// it works and let compiler combine numbers
subpixelbuffer2[1+4],
subpixelbuffer2[3+12],
subpixelbuffer2[1+12],
subpixelbuffer2[2+4],
subpixelbuffer2[0+4],
subpixelbuffer2[2+12],
subpixelbuffer2[0+12]);  
}





}//we close loop for reset of buffer after write 4 pixels at once done!
#endif //subpixelcoloroptimized == 2
#if subpixelcoloroptimized == 3 //we finish write update to display

//we write 16 squarea at a time to display. this reduces command calls drastically
//this write only happens every 16 loops to display! we capture 16 pixels and update all at one time!
if (jx32<16){
tft.fillRectFast64colors(jx32*4+
offsetx32+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetx32+tempintx*(raster_yxx*interpolateSampleDir),
16,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
16,//we divide hieght of pixels.
//0.        8        32        40
//[0][2]  [0][2]  [0][2]  [0][2]  //this is how this side of data is sent to display
//[1][3]  [1][3]  [1][3]  [1][3] //we buffer it and reorder it so it goes in sequence
//4       12       36      44
//[0][2]  [0][2]  [0][2]  [0][2]
//[1][3]  [1][3]  [1][3]  [1][3]
//16      20      48       56
//[0][2]  [0][2]  [0][2]  [0][2]
//[1][3]  [1][3]  [1][3]  [1][3] 
//24       28     52       60
//[0][2]  [0][2]  [0][2]  [0][2]
//[1][3]  [1][3]  [1][3]  [1][3]
subpixelbuffer2[0+0],subpixelbuffer2[0+2],subpixelbuffer2[8+0],subpixelbuffer2[8+2],subpixelbuffer2[32+0],subpixelbuffer2[32+2],subpixelbuffer2[40+0],subpixelbuffer2[40+2],//row0
subpixelbuffer2[0+1],subpixelbuffer2[0+3],subpixelbuffer2[8+1],subpixelbuffer2[8+3],subpixelbuffer2[32+1],subpixelbuffer2[32+3],subpixelbuffer2[40+1],subpixelbuffer2[40+3],//row1
subpixelbuffer2[4+0],subpixelbuffer2[4+2],subpixelbuffer2[12+0],subpixelbuffer2[12+2],subpixelbuffer2[36+0],subpixelbuffer2[36+2],subpixelbuffer2[44+0],subpixelbuffer2[44+2],//row2
subpixelbuffer2[4+1],subpixelbuffer2[4+3],subpixelbuffer2[12+1],subpixelbuffer2[12+3],subpixelbuffer2[36+1],subpixelbuffer2[36+3],subpixelbuffer2[44+1],subpixelbuffer2[44+3],//row3
subpixelbuffer2[16+0],subpixelbuffer2[16+2],subpixelbuffer2[20+0],subpixelbuffer2[20+2],subpixelbuffer2[48+0],subpixelbuffer2[48+2],subpixelbuffer2[56+0],subpixelbuffer2[56+2],//row4
subpixelbuffer2[16+1],subpixelbuffer2[16+3],subpixelbuffer2[20+1],subpixelbuffer2[20+3],subpixelbuffer2[48+1],subpixelbuffer2[48+3],subpixelbuffer2[56+1],subpixelbuffer2[56+3],//row5
subpixelbuffer2[24+0],subpixelbuffer2[24+2],subpixelbuffer2[28+0],subpixelbuffer2[28+2],subpixelbuffer2[52+0],subpixelbuffer2[52+2],subpixelbuffer2[60+0],subpixelbuffer2[60+2],//row6
subpixelbuffer2[24+1],subpixelbuffer2[24+3],subpixelbuffer2[28+1],subpixelbuffer2[28+3],subpixelbuffer2[52+1],subpixelbuffer2[52+3],subpixelbuffer2[60+1],subpixelbuffer2[60+3]//row7
);  
}else{
tft.fillRectFast64colors(jx32*4+
offsetx32+ tempintx*(raster_xxx*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
ix32*4+offsetx32+tempintx*(raster_yxx*interpolateSampleDir),
16,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
16,//we divide hieght of pixels.
//0.        8        32        40
//[3][1]  [3][1]  [3][1]  [3][1]   //this is how this side of data is sent to display
//[2][0]  [2][0]  [2][0]  [2][0]  //we buffer it and reorder it so it goes in sequence
//4       12       36      44
//[3][1]  [3][1]  [3][1]  [3][1]  
//[2][0]  [2][0]  [2][0]  [2][0]
//16      20      48       56
//[3][1]  [3][1]  [3][1]  [3][1]  
//[2][0]  [2][0]  [2][0]  [2][0]
//24       28     52       60
//[3][1]  [3][1]  [3][1]  [3][1]  
//[2][0]  [2][0]  [2][0]  [2][0]
subpixelbuffer2[0+3],subpixelbuffer2[0+1],subpixelbuffer2[8+3],subpixelbuffer2[8+1],subpixelbuffer2[32+3],subpixelbuffer2[32+1],subpixelbuffer2[40+3],subpixelbuffer2[40+1],//row0
subpixelbuffer2[0+2],subpixelbuffer2[0+0],subpixelbuffer2[8+2],subpixelbuffer2[8+0],subpixelbuffer2[32+2],subpixelbuffer2[32+0],subpixelbuffer2[40+2],subpixelbuffer2[40+0],//row1
subpixelbuffer2[4+3],subpixelbuffer2[4+1],subpixelbuffer2[12+3],subpixelbuffer2[12+1],subpixelbuffer2[36+3],subpixelbuffer2[36+1],subpixelbuffer2[44+3],subpixelbuffer2[44+1],//row2
subpixelbuffer2[4+2],subpixelbuffer2[4+0],subpixelbuffer2[12+2],subpixelbuffer2[12+0],subpixelbuffer2[36+2],subpixelbuffer2[36+0],subpixelbuffer2[44+2],subpixelbuffer2[44+0],//row3
subpixelbuffer2[16+3],subpixelbuffer2[16+1],subpixelbuffer2[20+3],subpixelbuffer2[20+1],subpixelbuffer2[48+3],subpixelbuffer2[48+1],subpixelbuffer2[56+3],subpixelbuffer2[56+1],//row4
subpixelbuffer2[16+2],subpixelbuffer2[16+0],subpixelbuffer2[20+2],subpixelbuffer2[20+0],subpixelbuffer2[48+2],subpixelbuffer2[48+0],subpixelbuffer2[56+2],subpixelbuffer2[56+0],//row5
subpixelbuffer2[24+3],subpixelbuffer2[24+1],subpixelbuffer2[28+3],subpixelbuffer2[28+1],subpixelbuffer2[52+3],subpixelbuffer2[52+1],subpixelbuffer2[60+3],subpixelbuffer2[60+1],//row6
subpixelbuffer2[24+2],subpixelbuffer2[24+0],subpixelbuffer2[28+2],subpixelbuffer2[28+0],subpixelbuffer2[52+2],subpixelbuffer2[52+0],subpixelbuffer2[60+2],subpixelbuffer2[60+0]//row7
);    
}





}//we close loop for reset of buffer after write 4 pixels at once done!
#endif //subpixelcoloroptimized == 2
//*********end of 64 bit rectangle writes!
raster_yxx +=  interpolateSampleDir;
   }//interpolatepixel_y 

   raster_xxx += interpolateSampleDir;
}//interpolatepixel_x  
 ix32++;
}//ixx32
 jx32++;
}//jxx32

#endif  //interpolateMode
//********************this is end of 32x32 upsampled to 64x64 buffer*********************************
 ixx++;
}//ixx
 jxx++;
}//jxx
#endif //interpolatemode ==2 end
#if  showcolorbar == true 
}   
#endif

//this is end of 32*32 upscale of buffer
//below ends the check buffer loop
#if optimize > 0 
}
#endif
#if optimize >1 
    }
#endif
#if noisefilter > 0 & optimize == 2 //optimize needs to be 2 for noise filter to work
  } //we add in case noise filter code in existence
#endif  
long tempt=micros()-timer;
Serial.println(tempt);
      i++;   
//old way
  //         tft.fillRect(displayPixelHeight * (i /8), displayPixelWidth * (i % 8),
    //    displayPixelHeight, displayPixelWidth, camColors[colorIndex]);




  }
//we keep lines below for testing results  
//timer =micros()-timer;
//Serial.println(timer);
//we sample one time per frame 
//4000 is just an upper limit i pulled out of thin air, more color space requires wider range
 if (compressionnumber>speedUpCompression){if (compressionflux<50) {compressionflux+=1;};
 }//we increase range more slowly 
 else{
  if (compressionflux>0){compressionflux-=1;}//else{if (compressionflux>0){compressionflux-=1;}}
 }


//Serial.println(compressionnumber);//for testing
#if interpolatemode > 2 //this for testin 32x32 buffer, to then upscale to 64x64
//this code is for output of buffer to display it tests buffer to make sure it is working correctly. now it is!
//this buffer that it is testing will go away eventually.
/*
for (int jx=0;jx<16;jx++){
for (int ix=0;ix<16;ix++){
//this is where subsample 32x32 code is put



//line below outputs 16x16 data,we want to sub sample that data! this is temp. eventually buffer will not be needed.
fillRectFast(jx*8 , //we reduce pixle size and step over in raster extra pixels created
ix*8,
8,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
8,//we divide hieght of pixels.
(uint16_t)pgm_read_word_near(camColors+postbuffer[jx*16+ix]));  //we update pixel location with new subsampled pixel.

}
}
*/
/*
//32x32 buffer works test 32x32 buffer just the buffer
for (int jx2=0;jx2<32;jx2++){
for (int ix2=0;ix2<32;ix2++){
//this is where subsample 32x32 code is put
Serial.println(ix2);


//line below outputs 16x16 data,we want to sub sample that data! this is temp. eventually buffer will not be needed.
fillRectFast(jx2*4 , //we reduce pixle size and step over in raster extra pixels created
ix2*4,
4,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
4,//we divide hieght of pixels.
(uint16_t)pgm_read_word_near(camColors+postbuffer2[jx2*32+ix2]));  //we update pixel location with new subsampled pixel.

}
}
*/
#endif

displayaddons();//this is for bar and number showing
}


